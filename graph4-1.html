<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Graph Tool – Clipboard Tap, Zoom, Floating Menu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <style>
    :root { --pt10px: 13.333px; }
    * { box-sizing: border-box; }
    html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: Helvetica, Arial, sans-serif; font-size: var(--pt10px); }
    #stageWrap { position: fixed; inset: 0; touch-action: none; background: #fff; }

    /* Floating three-dots menu (always above canvas) */
    .fab { position: fixed; right: 16px; bottom: 16px; width: 56px; height: 56px; border-radius: 50%; background:#111; color:#fff; display:flex; align-items:center; justify-content:center; font-size: 24px; box-shadow: 0 8px 20px rgba(0,0,0,.25); z-index: 9999; user-select: none; }
    .fab:active { transform: scale(0.98); }
    .menu { position: fixed; right: 16px; bottom: 80px; background:#fff; border:1px solid #e6e6e6; border-radius: 12px; box-shadow: 0 10px 24px rgba(0,0,0,.18); display:none; flex-direction: column; overflow: hidden; z-index: 9999; }
    .menu button { appearance: none; border:0; background:#fff; padding: 12px 16px; text-align:left; font-size: var(--pt10px); min-width: 160px; }
    .menu button:hover { background:#f5f5f5; }

    .hint { position: fixed; left: 50%; transform: translateX(-50%); bottom: 12px; padding: 6px 10px; background: rgba(0,0,0,.75); color:#fff; border-radius: 999px; font-size: var(--pt10px); pointer-events: none; opacity: 0; transition: opacity .2s; z-index: 9998; }
    .hint.show { opacity: 1; }
  </style>
</head>
<body>
  <div id="stageWrap"></div>

  <!-- Floating Action Button (three dots) -->
  <div class="fab" id="fab" aria-label="Menu" title="Menu">⋮</div>
  <div class="menu" id="menu">
    <button id="btnConnect">Connect</button>
    <button id="btnUndo">Undo</button>
    <button id="btnClear">Clear</button>
    <button id="btnSave">Save PNG</button>
  </div>

  <div class="hint" id="hint"></div>

  <script>
    /*****************
     * Config & State
     *****************/
    const PT10 = 13.333; // 10pt in px
    const STORAGE_KEY = 'graphTool_v3';
    const NODE_RADIUS = 28; // visual circle
    const ICON_SIZE = 24;   // SVG icon box

    // Inline SVG logos (simplified). Logos are trademarks of their owners.
    const SVG_ICONS = {
      facebook: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#1877F2" d="M24 12.073C24 5.405 18.627 0 12 0S0 5.405 0 12.073C0 18.1 4.388 23.093 10.125 24v-8.437H7.078V12.07h3.047V9.412c0-3.007 1.79-4.67 4.533-4.67 1.313 0 2.686.235 2.686.235v2.953h-1.514c-1.492 0-1.954.928-1.954 1.88v2.259h3.328l-.532 3.492h-2.796V24C19.612 23.093 24 18.1 24 12.073z"/></svg>',
      twitterx: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.244 2H21.5l-7.59 8.67L23.5 22h-7.08l-5.53-6.62L3.66 22H.5l8.1-9.26L.5 2h7.2l5.01 5.99L18.244 2Zm-1.24 18h1.94L7.06 4H5.06l11.944 16z"/></svg>',
      youtube: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect width="24" height="24" rx="4" fill="#FF0000"/><path fill="#fff" d="M9 16V8l6 4-6 4z"/></svg>',
      instagram: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="5"/><circle cx="12" cy="12" r="4"/><circle cx="17.5" cy="6.5" r="1.25"/></svg>',
      linkedin: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4.98 3.5a2.5 2.5 0 1 1 0 5.001 2.5 2.5 0 0 1 0-5zM3 9h4v12H3zM14.5 9c-2.21 0-3.5 1.204-3.5 2.863V21h-4V9h4v1.65S12.09 9 14.7 9c2.61 0 4.3 1.73 4.3 4.73V21h-4v-6.5c0-1.4-.78-2.5-2.5-2.5z"/></svg>',
      reddit: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 12.5c0-.88-.72-1.6-1.6-1.6-.6 0-1.13.33-1.4.82-1.16-.73-2.68-1.2-4.35-1.27l.74-3.49 2.43.51a1.6 1.6 0 1 0 .2-1l-2.9-.6a.75.75 0 0 0-.88.56l-.96 4.49c-1.82.05-3.48.52-4.73 1.28-.28-.5-.81-.85-1.42-.85-.89 0-1.6.72-1.6 1.6 0 .66.39 1.22.95 1.47-.04.24-.06.48-.06.73 0 2.67 3.07 4.84 6.86 4.84s 6.86-2.17 6.86-4.84c0-.25-.02-.5-.06-.74.56-.26.96-.82.96-1.46z"/></svg>',
      github: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 .5C5.73.5.98 5.24.98 11.5c0 4.85 3.15 8.96 7.5 10.41.55.1.75-.24.75-.53 0-.26-.01-1.13-.02-2.05-3.05.66-3.7-1.3-3.7-1.3-.5-1.28-1.22-1.62-1.22-1.62-.99-.67.07-.66.07-.66 1.1.08 1.69 1.12 1.69 1.12.98 1.67 2.56 1.19 3.18.91.1-.71.38-1.19.7-1.46-2.44-.28-5-1.22-5-5.45 0-1.2.43-2.18 1.13-2.96-.12-.28-.49-1.41.11-2.94 0 0 .92-.3 3.02 1.13a10.5 10.5 0 0 1 5.5 0c2.1-1.43 3.02-1.13 3.02-1.13.6 1.53.23 2.66.11 2.94.7.78 1.13 1.76 1.13 2.96 0 4.24-2.57 5.16-5.02 5.44.39.34.74 1 .74 2.01 0 1.45-.01 2.63-.01 2.99.0 .29.2.64.76.53 4.34-1.45 7.49-5.56 7.49-10.41C23.02 5.24 18.27.5 12 .5z"/></svg>',
      wikipedia: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M2 5h3.3l4.5 10.2L13.6 5H17l-5.5 12.7c-.2.46-.45.85-.78 1.17-.33.32-.8.63-1.37.63-.58 0-1.06-.3-1.4-.62-.33-.33-.58-.72-.78-1.18L2 5zm19.6 0H24l-4.92 11.36L17.5 13l4.1-8z"/></svg>',
      link: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3.9 12a4.1 4.1 0 0 1 4.1-4.1h3V9h-3a3 3 0 0 0 0 6h3v1.1h-3A4.1 4.1 0 0 1 3.9 12zm12.1-4.1h-3V9h3a3 3 0 0 1 0 6h-3v1.1h3a4.1 4.1 0 1 0 0-8.2zM8 11.4h8v1.2H8z"/></svg>'
    };

    const ICON_MAP = [
      {match: /facebook\.com/i, key: 'facebook'},
      {match: /(twitter\.com|x\.com)/i, key: 'twitterx'},
      {match: /youtube\.com|youtu\.be/i, key: 'youtube'},
      {match: /instagram\.com/i, key: 'instagram'},
      {match: /linkedin\.com/i, key: 'linkedin'},
      {match: /reddit\.com/i, key: 'reddit'},
      {match: /github\.com/i, key: 'github'},
      {match: /wikipedia\.org/i, key: 'wikipedia'},
      {match: /.*/, key: 'link'}
    ];

    function iconKeyFor(url){ return (ICON_MAP.find(e=>e.match.test(url))||ICON_MAP[ICON_MAP.length-1]).key; }
    function domainFrom(url){ try { return new URL(url).hostname.replace(/^www\./i,''); } catch { return url; } }
    function svgToDataURL(svg){ const enc = encodeURIComponent(svg).replace(/'/g, '%27').replace(/\(/g, '%28').replace(/\)/g, '%29'); return `data:image/svg+xml;charset=utf-8,${enc}`; }

    // Action history (undo adds only)
    const history = []; // entries: {type:'add-node', id} or {type:'add-edge', id}

    // Graph data
    const graph = { nodes: [], edges: [] }; // nodes: {id,url,x,y,comment}
    let idSeq = 1;

    // Konva stage
    const stageWrap = document.getElementById('stageWrap');
    const stage = new Konva.Stage({ container: 'stageWrap', width: stageWrap.clientWidth, height: stageWrap.clientHeight });

    // Single layer + root group centered in stage
    const layer = new Konva.Layer();
    stage.add(layer);
    const rootGroup = new Konva.Group({ x: stage.width()/2, y: stage.height()/2, scaleX: 1, scaleY: 1 });
    layer.add(rootGroup);

    // containers within root group (same local coordinate system)
    const edgesContainer = new Konva.Group();
    const nodesContainer = new Konva.Group();
    rootGroup.add(edgesContainer);
    rootGroup.add(nodesContainer);

    // Resize handling: keep center
    function resizeStage(){
      stage.size({ width: stageWrap.clientWidth, height: stageWrap.clientHeight });
      rootGroup.position({ x: stage.width()/2, y: stage.height()/2 });
      stage.batchDraw();
    }
    window.addEventListener('resize', resizeStage);

    // Helpers to convert between stage and root-local coordinates
    function toLocalFromStage(p){
      const s = rootGroup.scaleX();
      return { x: (p.x - rootGroup.x()) / s, y: (p.y - rootGroup.y()) / s };
    }

    // Node/edge lookup helpers
    const findNodeGroup = (id) => nodesContainer.findOne(`#node-${id}`);
    const findEdgeShape = (id) => edgesContainer.findOne(`#edge-${id}`);

    // Show hint toast
    const hintEl = document.getElementById('hint');
    function hint(msg, ms=1400){
      hintEl.textContent = msg;
      hintEl.classList.add('show');
      clearTimeout(hint._t);
      hint._t = setTimeout(()=> hintEl.classList.remove('show'), ms);
    }

    /*****************
     * Clipboard read
     *****************/
    async function readClipboardUrl(){
      // Try navigator.clipboard.readText() first
      try {
        const text = await navigator.clipboard.readText();
        const url = extractFirstUrl(text);
        if(url) return url;
      } catch (e) { /* fall through */ }
      // Fallback: prompt user to paste manually
      const pasted = prompt('Paste a link to add:');
      if(!pasted) return null;
      const url = extractFirstUrl(pasted.trim());
      return url;
    }

    function extractFirstUrl(str){ if(!str) return null; const m = str.match(/https?:\/\/[^\s\)\]}"'<>]+/i); return m ? m[0] : null; }

    /*****************
     * Drawing
     *****************/
    function drawNode(node){
      const g = new Konva.Group({ id: `node-${node.id}`, x: node.x, y: node.y, draggable: true });

      const bg = new Konva.Circle({ radius: NODE_RADIUS, fill:'#f6f6f6', stroke:'#444', strokeWidth:1.5, shadowColor:'rgba(0,0,0,0.12)', shadowBlur:6, shadowOffset:{x:0,y:1} });

      const key = iconKeyFor(node.url);
      const img = new Image(); img.src = svgToDataURL(SVG_ICONS[key] || SVG_ICONS.link);
      const icon = new Konva.Image({ image: img, width: ICON_SIZE, height: ICON_SIZE, offset: {x: ICON_SIZE/2, y: ICON_SIZE/2}, y: -2 });

      const domainLabel = new Konva.Text({ text: domainFrom(node.url), fontFamily:'Helvetica, Arial, sans-serif', fontSize: PT10, fill:'#333', y: NODE_RADIUS + 4, align:'center' });
      // comment text
      const commentText = new Konva.Text({ text: node.comment || '', fontFamily:'Helvetica, Arial, sans-serif', fontSize: PT10, fill:'#111', y: NODE_RADIUS + 4 + PT10 + 4, width: 180, align:'center' });
      commentText.offsetX(90);

      g.add(bg); g.add(icon); g.add(domainLabel); g.add(commentText);
      // Center domain after adding
      domainLabel.offsetX(domainLabel.width()/2);

      // Double click/tap => edit comment (disabled during connect mode)
      g.on('dblclick dbltap', ()=>{
        if(connectMode) return;
        const val = prompt('Add/edit comment:', node.comment || '');
        if(val !== null){ node.comment = val.trim(); commentText.text(node.comment); saveState(); layer.batchDraw(); }
      });

      // If connect mode is on, a simple tap will select endpoints
      g.on('click tap', (e)=>{
        if(!connectMode) return;
        const id = node.id;
        if(connectStart == null){ connectStart = id; hint('Now tap the target node'); }
        else if(connectStart === id){ connectStart = null; hint('Canceled'); }
        else { addEdge(connectStart, id); connectStart = null; setConnectMode(false); hint('Connected'); }
      });

      // Drag move updates edges (NOT tracked by undo)
      g.on('dragmove', ()=>{ node.x = g.x(); node.y = g.y(); updateEdgesForNode(node.id); saveState(); });

      nodesContainer.add(g); layer.batchDraw(); return g;
    }

    function drawEdge(edge){
      const fromG = findNodeGroup(edge.from); const toG = findNodeGroup(edge.to);
      const line = new Konva.Arrow({ id:`edge-${edge.id}`, points: [fromG.x(), fromG.y(), toG.x(), toG.y()], stroke:'#666', fill:'#666', pointerLength:8, pointerWidth:8, strokeWidth:1.5, lineCap:'round', lineJoin:'round' });
      edgesContainer.add(line); layer.batchDraw(); return line;
    }

    function updateEdgesForNode(nodeId){
      graph.edges.forEach(e=>{ if(e.from===nodeId||e.to===nodeId){ const ln = findEdgeShape(e.id); if(ln){ const fromG = findNodeGroup(e.from); const toG = findNodeGroup(e.to); ln.points([fromG.x(), fromG.y(), toG.x(), toG.y()]); } } });
      layer.batchDraw();
    }

    /*****************
     * Graph ops
     *****************/
    function addNode(url, posLocal){ const node = { id: idSeq++, url, x: posLocal.x, y: posLocal.y, comment: '' }; graph.nodes.push(node); drawNode(node); history.push({ type:'add-node', id: node.id }); saveState(); }

    function removeNode(id){ const g = findNodeGroup(id); if(g) g.destroy(); const edgeIds = graph.edges.filter(e=>e.from===id||e.to===id).map(e=>e.id); edgeIds.forEach(removeEdge); const idx = graph.nodes.findIndex(n=>n.id===id); if(idx>=0) graph.nodes.splice(idx,1); layer.draw(); saveState(); }

    function addEdge(fromId, toId){ const edge = { id: idSeq++, from: fromId, to: toId }; graph.edges.push(edge); drawEdge(edge); history.push({ type:'add-edge', id: edge.id }); saveState(); }
    function removeEdge(id){ const ln = findEdgeShape(id); ln && ln.destroy(); const idx = graph.edges.findIndex(e=>e.id===id); if(idx>=0) graph.edges.splice(idx,1); layer.draw(); saveState(); }

    /*****************
     * Persistence
     *****************/
    function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify({ idSeq, nodes: graph.nodes, edges: graph.edges })); }
    function loadState(){ const raw = localStorage.getItem(STORAGE_KEY); if(!raw) return; try { const data = JSON.parse(raw); idSeq = data.idSeq || 1; graph.nodes = data.nodes || []; graph.edges = data.edges || []; graph.nodes.forEach(drawNode); graph.edges.forEach(drawEdge); } catch(e){ console.warn('Load failed', e); } }

    /*****************
     * Connect mode
     *****************/
    let connectMode = false; let connectStart = null;
    function setConnectMode(on){ connectMode = on; hint(connectMode ? 'Connect: tap first node, then second.' : 'Connect off'); connectStart = null; }

    /*****************
     * Stage interactions
     *****************/
    // Add node on empty canvas tap/click → read clipboard URL or prompt
    stage.on('click tap', async (evt)=>{
      if(evt.target !== stage) return; // ignore clicks on nodes/edges
      const pointer = stage.getPointerPosition(); if(!pointer) return;
      const url = await readClipboardUrl();
      if(!url){ hint('Could not read link.'); return; }
      const posLocal = toLocalFromStage(pointer); addNode(url, posLocal); hint('Node added');
    });

    // Zoom (wheel) – desktop
    stage.on('wheel', (e)=>{
      e.evt.preventDefault();
      const oldScale = rootGroup.scaleX();
      const pointer = stage.getPointerPosition();
      const scaleBy = 1.05;
      let newScale = e.evt.deltaY > 0 ? oldScale/scaleBy : oldScale*scaleBy;
      newScale = Math.max(0.5, Math.min(3, newScale));
      // scale around pointer
      const mousePointTo = { x: (pointer.x - rootGroup.x()) / oldScale, y: (pointer.y - rootGroup.y()) / oldScale };
      rootGroup.scale({ x: newScale, y: newScale });
      rootGroup.position({ x: pointer.x - mousePointTo.x * newScale, y: pointer.y - mousePointTo.y * newScale });
      stage.batchDraw();
    });

    // Pinch-to-zoom – mobile (two fingers)
    let lastDist = 0;
    function getTouchCenter(touches){ return { x: (touches[0].clientX + touches[1].clientX)/2, y: (touches[0].clientY + touches[1].clientY)/2 }; }
    function getTouchDist(touches){ const dx = touches[0].clientX - touches[1].clientX; const dy = touches[0].clientY - touches[1].clientY; return Math.hypot(dx,dy); }

    stage.on('touchmove', (e)=>{
      const t = e.evt.touches; if(t.length !== 2) return; e.evt.preventDefault();
      const centerClient = getTouchCenter(t); const dist = getTouchDist(t);
      if(!lastDist){ lastDist = dist; return; }
      const oldScale = rootGroup.scaleX();
      let newScale = oldScale * (dist / lastDist); newScale = Math.max(0.5, Math.min(3, newScale));
      const pointer = { x: centerClient.x, y: centerClient.y };
      const pointTo = { x: (pointer.x - rootGroup.x()) / oldScale, y: (pointer.y - rootGroup.y()) / oldScale };
      rootGroup.scale({ x: newScale, y: newScale });
      rootGroup.position({ x: pointer.x - pointTo.x * newScale, y: pointer.y - pointTo.y * newScale });
      stage.batchDraw();
      lastDist = dist;
    });
    stage.on('touchend', (e)=>{ if(e.evt.touches.length < 2){ lastDist = 0; } });

    /*****************
     * Floating menu
     *****************/
    const fab = document.getElementById('fab'); const menu = document.getElementById('menu');
    fab.addEventListener('click', ()=>{ menu.style.display = (menu.style.display==='flex') ? 'none' : 'flex'; if(menu.style.display==='flex'){ menu.style.flexDirection='column'; } });
    document.getElementById('btnConnect').addEventListener('click', ()=>{ setConnectMode(!connectMode); });
    document.getElementById('btnUndo').addEventListener('click', ()=>{ const last = history.pop(); if(!last) return; if(last.type==='add-node'){ removeNode(last.id); } else if(last.type==='add-edge'){ removeEdge(last.id); } });
    document.getElementById('btnClear').addEventListener('click', ()=>{ if(!confirm('Clear canvas and local data?')) return; // clear visuals & data
      nodesContainer.destroyChildren(); edgesContainer.destroyChildren(); graph.nodes.length=0; graph.edges.length=0; idSeq=1; history.length=0; layer.draw(); localStorage.removeItem(STORAGE_KEY); });
    document.getElementById('btnSave').addEventListener('click', ()=>{ const dataURL = stage.toDataURL({ pixelRatio: 2 }); const a=document.createElement('a'); a.href=dataURL; a.download='graph.png'; document.body.appendChild(a); a.click(); a.remove(); });

    /*****************
     * Init
     *****************/
    function init(){ resizeStage(); loadState(); hint('Tap empty canvas to add link from clipboard'); }
    init();
  </script>
</body>
</html>
