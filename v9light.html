<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Konva Node Graph – DOM Sidebar + Canvas Zoom + Persistence</title>
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --sidebar-w: 150px; /* half of previous */
      --ui-bg: #f8f7f6;
      --ui-panel: #f8f7f6;
      --ui-border: #e5e4e3;
      --ui-text: #646362;
      --ui-muted: #9aa4b2;
      --ui-accent: #7aa2f7;
    }
    * { box-sizing: border-box; }
    body { margin: 0; height: 100vh; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: var(--ui-bg); color: var(--ui-text); }

    /* Sidebar sits above canvas; not affected by stage zoom */
    #sidebar {
      position: fixed; inset: 0 auto 0 0; width: var(--sidebar-w); z-index: 20;
      background: var(--ui-panel); border-right: 1px solid var(--ui-border);
      display: grid; grid-template-rows: auto 1fr auto; gap: 8px; padding: 10px;
    }
    #sidebar h2 { margin: 0; font-size: 14px; color: var(--ui-muted); letter-spacing: .04em; text-transform: uppercase; }
    .palette { display: grid; gap: 8px; align-content: start; padding-top: 6px; }
    .chip { display: flex; align-items: center; gap: 6px; padding: 6px; border: 0; border-radius: 0; background: transparent; cursor: grab; justify-content: flex-start; text-align: left; font-weight: 500; color: #1d1c1b;}
    .chip:hover { display: flex; align-items: center; gap: 6px; padding: 6px; border: 0; border-radius: 16px; background: #eeedec; cursor: grab; justify-content: flex-start; text-align: left; }
    .chip:active { cursor: grabbing; }
    .chip span { font-size: 14px; text-align: left; }
    .chip[draggable="true"] { user-select: none; }

    .actions { display: grid; gap: 8px; }
    .btn { padding: 6px 8px; border-radius: 0; border: 0; background: transparent; color: var(--ui-text); cursor: pointer; font-size: 14px; text-align: left; }
    .btn:hover { padding: 6px 8px; border-radius: 16px; border: 0; background: #eeedec; color: var(--ui-text); cursor: pointer; font-size: 14px; text-align: left; }
    /*.btn:hover { filter: brightness(1.08); }

    /* Canvas container fills remaining space */
    #container-wrap { position: absolute; left: var(--sidebar-w); top: 0; right: 0; bottom: 0; }
    #container { width: 100%; height: 100%; }

    /* Mobile bumps for HTML-only UI (sidebar) */
    @media (max-width: 600px), (pointer: coarse) {
      :root { --sidebar-w: 116px; }
      .chip span { font-size: 16px; }
      .btn { font-size: 16px; padding: 8px 10px; }
    }
  </style>
</head>
<body>
  <!-- Sidebar (DOM) -->
  <aside id="sidebar">
    <h2>Nodes</h2>
 <div class="palette" id="palette">
      <div class="chip" draggable="true" data-type="Person"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><path d="M0 0h24v24H0z" fill="none"/><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg><span>Person</span></div>
      <div class="chip" draggable="true" data-type="Entity"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><path d="M0 0h24v24H0z" fill="none"/><path d="M12 7V3H2v18h20V7H12zM6 19H4v-2h2v2zm0-4H4v-2h2v2zm0-4H4V9h2v2zm0-4H4V5h2v2zm4 12H8v-2h2v2zm0-4H8v-2h2v2zm0-4H8V9h2v2zm0-4H8V5h2v2zm10 12h-8v-2h2v-2h-2v-2h2v-2h-2V9h8v10zm-2-8h-2v2h2v-2zm0 4h-2v2h2v-2z"/></svg><span>Entity</span></div>
      <div class="chip" draggable="true" data-type="Email"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><path d="M0 0h24v24H0z" fill="none"/><path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/></svg><span>Email</span></div>
      <div class="chip" draggable="true" data-type="Social Media"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><path d="M0 0h24v24H0z" fill="none"/><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10h5v-2h-5c-4.34 0-8-3.66-8-8s3.66-8 8-8 8 3.66 8 8v1.43c0 .79-.71 1.57-1.5 1.57s-1.5-.78-1.5-1.57V12c0-2.76-2.24-5-5-5s-5 2.24-5 5 2.24 5 5 5c1.38 0 2.64-.56 3.54-1.47.65.89 1.77 1.47 2.96 1.47 1.97 0 3.5-1.6 3.5-3.57V12c0-5.52-4.48-10-10-10zm0 13c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"/></svg><span>Social</span></div>
    </div>

    <div></div>

    <div class="actions">
      <button class="btn" id="normalModeBtn">Normal Mode</button>
      <button class="btn" id="undoBtn">Undo</button>
      <button class="btn" id="deleteModeBtn">Delete</button>
      <button class="btn" id="exportBtn">Export</button>
      <button class="btn" id="clearBtn">New</button>
    </div>
  </aside>

  <!-- Canvas area -->
  <div id="container-wrap">
    <div id="container"></div>
  </div>

<script>
// --- Stage
var width = document.getElementById('container').clientWidth;
var height = document.getElementById('container').clientHeight;
var stage = new Konva.Stage({ container: 'container', width: width, height: height, draggable: true });
Konva.hitOnDragEnabled = true;

// Device heuristics (larger nodes/menu on phones)
const isPhone = window.matchMedia('(max-width: 600px)').matches || window.matchMedia('(pointer: coarse)').matches;
const NODE_SCALE = 1.0;

// --- Layers: background → edges → nodes
var backgroundLayer = new Konva.Layer({ listening: false });
var edgesLayer = new Konva.Layer({ listening: false });
var nodesLayer = new Konva.Layer();

var bgRect = new Konva.Rect({ x: 0, y: 0, width: stage.width(), height: stage.height(), fill: 'white', listening: false });
backgroundLayer.add(bgRect);
stage.add(backgroundLayer); stage.add(edgesLayer); stage.add(nodesLayer); backgroundLayer.moveToBottom();

window.addEventListener('resize', () => {
  const wrap = document.getElementById('container');
  stage.width(wrap.clientWidth); stage.height(wrap.clientHeight);
  bgRect.width(stage.width()); bgRect.height(stage.height());
  stage.batchDraw();
});

// --- State
var connections = [];
var nodes = [];
var selectedMode = 'none';
var tempArrow = null; var startNode = null;

// persistence
var STORAGE_KEY = 'konva_graph_state_v1';
var nidCounter = 1;
function nextNid(){ return 'n' + (nidCounter++); }

function debounce(fn, ms){ let t; return function(){ clearTimeout(t); const a=arguments, c=this; t=setTimeout(()=>fn.apply(c,a), ms); }; }
const saveViewDebounced = debounce(saveState, 400);

// Expose actions for sidebar buttons
window.setMode = setMode; window.undoConnection = undoConnection; window.exportJPEG = exportJPEG; window.clearCanvas = clearCanvas;

// --- Node metrics
var MIN_NODE_WIDTH = Math.round(120 * NODE_SCALE);
var iconSize      = Math.round(40  * NODE_SCALE);
var iconHitRadius = Math.round(30  * NODE_SCALE);
var GAP           = Math.round(16   * NODE_SCALE);
var PADDING_X     = Math.round(8   * NODE_SCALE);
var EDGE_GAP      = Math.round(30   * NODE_SCALE);
var dragThreshold = isPhone ? 8 : 5;
var LONG_PRESS_MS = isPhone ? 380 : 500;

var connectPressTimer = null; var pressPos = null; var isDraggingNode = false;
function cancelConnectTimer(){ if (connectPressTimer) { clearTimeout(connectPressTimer); connectPressTimer = null; } }

// --- Pointer helpers
function getPointerOnStage(){ var p = stage.getPointerPosition(); if (!p) return null; var t = stage.getAbsoluteTransform().copy().invert(); return t.point(p); }
function clientToStage(clientX, clientY){ var rect = stage.container().getBoundingClientRect(); var point = { x: clientX - rect.left, y: clientY - rect.top }; var t = stage.getAbsoluteTransform().copy().invert(); return t.point(point); }

// --- Icons (sample paths; swap with Material as desired)
function getPathData(type){ switch(type){
  case 'Person': return 'M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z';
  case 'Entity': return 'M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z';
  case 'Email': return 'M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z';
  case 'Social Media': return 'M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z';
  default: return ''; }}

// Colored halos per type
function colorForType(type){
  switch(type){
    case 'Person': return '#FFE08A';
    case 'Entity': return '#A7F3D0';
    case 'Email':  return '#BFDBFE';
    case 'Social Media': return '#FBCFE8';
    default: return 'yellow';
  }
}

// --- Autosize layout
function layoutNode(group){
  var circle = group.findOne('Circle'); var path = group.findOne('Path'); var text = group.findOne('Text');
  var textW = Math.ceil(text.getTextWidth()); var newWidth = Math.max(MIN_NODE_WIDTH, textW + PADDING_X*2);
  group.width(newWidth);
  var centerX = newWidth/2; circle.x(centerX); path.x(centerX);
  text.x(0); text.width(newWidth); text.y(iconSize + GAP);
  var newHeight = iconSize + GAP + text.height(); group.height(newHeight);
}

function createNode(type, centerX, centerY){
  var group = new Konva.Group({ x: centerX - MIN_NODE_WIDTH/2, y: centerY - (iconSize + GAP)/2, draggable: true, width: MIN_NODE_WIDTH, height: iconSize + GAP });
  group.setAttr('nid', nextNid()); group.setAttr('nodeType', type);

  var iconCenterX = MIN_NODE_WIDTH/2; var iconCenterY = iconSize/2;
  var circle = new Konva.Circle({ x: iconCenterX, y: iconCenterY, radius: iconHitRadius, fill: colorForType(type), opacity: 0.35 }); group.add(circle);
  var path = new Konva.Path({ x: iconCenterX, y: iconCenterY, data: getPathData(type), fill: 'black', scale: { x: iconSize/24, y: iconSize/24 }, offset: { x: 12, y: 12 } }); group.add(path);
  var text = new Konva.Text({ x: 0, y: iconSize + GAP, text: '', fontSize: Math.round(14 * NODE_SCALE), width: MIN_NODE_WIDTH, align: 'center', wrap: 'none', ellipsis: false }); group.add(text);

  layoutNode(group);

  group.on('dragstart', function(){ isDraggingNode = true; cancelConnectTimer(); });
  group.on('dragmove', function(){ updateConnectedArrows(this); });
  group.on('dragend', function(){ isDraggingNode = false; saveState(); });

  group.on('dblclick dbltap', function(){
    var currentText = text.text();
    var newTitle = prompt('Enter title:', currentText);
    if (newTitle !== null){ text.text(newTitle); layoutNode(group); stage.batchDraw(); saveState(); }
  });

  group.on('mousedown touchstart', function(e){
    if (selectedMode !== 'none') return;
    if (isDraggingNode) return;
    if (e.evt && (e.evt.button === 2)) return; // ignore right-click
    pressPos = getPointerOnStage();
    var node = this;
    cancelConnectTimer();
    connectPressTimer = setTimeout(function(){
      if (isDraggingNode) { cancelConnectTimer(); return; }
      startNode = node;
      var center = getIconCenter(startNode);
      var end = getPointerOnStage() || center;
      tempArrow = new Konva.Arrow({ points: [center.x, center.y, end.x, end.y], pointerLength: 10, pointerWidth: 10, fill: '#ccc', stroke: '#ccc', strokeWidth: 1 });
      edgesLayer.add(tempArrow);
      stage.batchDraw();
      startNode.draggable(false);
      cancelConnectTimer();
    }, LONG_PRESS_MS);
  });

  return group;
}

function getIconCenter(node){ var circle = node.findOne('Circle'); var box = circle.getClientRect({ relativeTo: stage }); return { x: box.x + box.width/2, y: box.y + box.height/2 }; }
function getIconRadius(node){ return node.findOne('Circle').radius(); }

function calculatePoints(from, to){
  var fromCenter = getIconCenter(from); var toCenter = getIconCenter(to);
  var dx = toCenter.x - fromCenter.x; var dy = toCenter.y - fromCenter.y;
  var dist = Math.sqrt(dx*dx + dy*dy) || 1; var ux = dx / dist, uy = dy / dist;
  var startOffset = getIconRadius(from) + EDGE_GAP; var endOffset = getIconRadius(to) + EDGE_GAP;
  var startX = fromCenter.x + ux * startOffset; var startY = fromCenter.y + uy * startOffset;
  var endX   = toCenter.x   - ux * endOffset;   var endY   = toCenter.y   - uy * endOffset;
  return [startX, startY, endX, endY];
}

function updateConnectedArrows(node){
  connections.forEach(function(conn){
    if (conn.from === node || conn.to === node){
      var points = calculatePoints(conn.from, conn.to);
      conn.arrow.points(points);
    }
  });
  stage.batchDraw();
}

function updateTempArrow(e){
  if (!tempArrow || !startNode) return;
  var pos = getPointerOnStage(); if (!pos) return;
  var center = getIconCenter(startNode);
  tempArrow.points([center.x, center.y, pos.x, pos.y]);
  stage.batchDraw();
}

function tryConnect(e){
  if (connectPressTimer) { cancelConnectTimer(); }
  if (!tempArrow) return;
  var pos = getPointerOnStage();
  var targetNode = null;
  nodes.forEach(function(node){
    if (node === startNode) return;
    var center = getIconCenter(node);
    var dx = pos.x - center.x; var dy = pos.y - center.y;
    var dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < iconHitRadius) targetNode = node;
  });
  if (targetNode){
    var points = calculatePoints(startNode, targetNode);
    var arrow = new Konva.Arrow({ points: points, pointerLength: 10, pointerWidth: 10, fill: '#ccc', stroke: '#ccc', strokeWidth: 1 });
    edgesLayer.add(arrow);
    connections.push({ from: startNode, to: targetNode, arrow: arrow });
    saveState();
  }
  if (tempArrow) { tempArrow.destroy(); tempArrow = null; }
  if (startNode) startNode.draggable(true);
  startNode = null;
  stage.batchDraw();
}

function deleteHandler(e){
  if (e.target === stage) return;
  var target = e.target.findAncestor('Group');
  if (target){
    connections = connections.filter(function(conn){ if (conn.from === target || conn.to === target){ conn.arrow.destroy(); return false; } return true; });
    nodes = nodes.filter(function(n){ return n !== target; });
    target.destroy();
    stage.batchDraw();
    saveState();
  }
}

function setMode(mode){ selectedMode = mode; stage.off('click'); if (mode === 'delete') stage.on('click', deleteHandler); }
function undoConnection(){ if (connections.length > 0){ var last = connections.pop(); last.arrow.destroy(); stage.batchDraw(); saveState(); } }
function exportJPEG() {
  // 1) Remember current transform
  var prevScale = { x: stage.scaleX(), y: stage.scaleY() };
  var prevPos   = { x: stage.x(),      y: stage.y() };

  // 2) Ensure the white background fully covers the stage
  bgRect.width(stage.width());
  bgRect.height(stage.height());

  // 3) Normalize the stage so there’s no scaled/panned transparent border
  stage.scale({ x: 1, y: 1 });
  stage.position({ x: 0, y: 0 });
  stage.batchDraw();

  // 4) Export at a higher pixel ratio if you like (crisper output)
  var dataURL = stage.toDataURL({
    mimeType: 'image/jpeg',
    quality: 1,
    pixelRatio: 2   // optional: 1 = native size; 2 = 2x resolution
  });

  // 5) Restore previous view
  stage.scale(prevScale);
  stage.position(prevPos);
  stage.batchDraw();

  // 6) Download
  var link = document.createElement('a');
  link.download = 'canvas.jpg';
  link.href = dataURL;
  link.click();
}
function clearCanvas(){ edgesLayer.destroyChildren(); nodesLayer.destroyChildren(); backgroundLayer.destroyChildren(); backgroundLayer.add(bgRect); connections = []; nodes = []; localStorage.removeItem(STORAGE_KEY); stage.batchDraw(); }

// Arrow updates & drag-threshold cancel
stage.on('mousemove touchmove', function(e){
  updateTempArrow(e);
  if (connectPressTimer){
    var pos = getPointerOnStage();
    if (pos && pressPos){
      var dx = pos.x - pressPos.x; var dy = pos.y - pressPos.y;
      if (Math.sqrt(dx*dx + dy*dy) > dragThreshold){ cancelConnectTimer(); }
    }
  }
});

stage.on('mouseup touchend', function(e){ if (isDraggingNode){ cancelConnectTimer(); } tryConnect(e); });

// Zoom: only canvas zooms; sidebar (DOM) is unaffected
stage.on('wheel', function(e){
  e.evt.preventDefault();
  var scaleBy = 1.05;
  var oldScale = stage.scaleX();
  var pointer = stage.getPointerPosition();
  if (!pointer) return;
  var direction = e.evt.deltaY > 0 ? 1 : -1;
  var newScale = direction > 0 ? oldScale / scaleBy : oldScale * scaleBy;
  var mousePointTo = { x: (pointer.x - stage.x()) / oldScale, y: (pointer.y - stage.y()) / oldScale };
  stage.scale({ x: newScale, y: newScale });
  var newPos = { x: pointer.x - mousePointTo.x * newScale, y: pointer.y - mousePointTo.y * newScale };
  stage.position(newPos);
  stage.batchDraw();
  saveViewDebounced();
});

// --- DOM Sidebar drag & drop → create node at drop position ---
const paletteEl = document.getElementById('palette');
const containerEl = stage.container();

paletteEl.querySelectorAll('.chip[draggable="true"]').forEach(el => {
  el.addEventListener('dragstart', (e) => {
    try { e.dataTransfer.setData('text/plain', el.dataset.type); } catch(_) {}
  });
});
containerEl.addEventListener('dragover', (e) => { e.preventDefault(); });
containerEl.addEventListener('drop', (e) => {
  e.preventDefault();
  let type = '';
  try { type = e.dataTransfer.getData('text/plain'); } catch(_) { type = ''; }
  if (!type) return;
  const pos = clientToStage(e.clientX, e.clientY);
  const node = createNode(type, pos.x, pos.y);
  nodesLayer.add(node); nodes.push(node);
  stage.batchDraw(); saveState();
});

// Sidebar buttons → existing actions
document.getElementById('undoBtn').onclick = () => undoConnection();
document.getElementById('deleteModeBtn').onclick = () => setMode('delete');
document.getElementById('normalModeBtn').onclick = () => setMode('none');
document.getElementById('exportBtn').onclick = () => exportJPEG();
document.getElementById('clearBtn').onclick = () => clearCanvas();

// --- Persistence (save/load) ---
function saveState(){
  try {
    var modelNodes = nodes.map(function(n){
      return {
        nid: n.getAttr('nid'),
        type: n.getAttr('nodeType'),
        x: n.x(), y: n.y(),
        text: (n.findOne('Text') ? n.findOne('Text').text() : '')
      };
    });
    var modelConns = connections.map(function(c){
      return { from: c.from.getAttr('nid'), to: c.to.getAttr('nid') };
    });
    var view = { scaleX: stage.scaleX(), scaleY: stage.scaleY(), x: stage.x(), y: stage.y() };
    var payload = { nodes: modelNodes, connections: modelConns, view: view, nidCounter: nidCounter };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  } catch(e){ /* ignore */ }
}

function loadState(){
  try {
    var raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    var data = JSON.parse(raw);
    if (data.view){ stage.scale({ x: data.view.scaleX || 1, y: data.view.scaleY || 1 }); stage.position({ x: data.view.x || 0, y: data.view.y || 0 }); }
    var map = {};
    (data.nodes || []).forEach(function(nm){
      var g = createNode(nm.type, nm.x + MIN_NODE_WIDTH/2, nm.y + (iconSize+GAP)/2);
      g.position({ x: nm.x, y: nm.y });
      g.setAttr('nid', nm.nid);
      var t = g.findOne('Text'); if (t){ t.text(nm.text || ''); layoutNode(g); }
      nodesLayer.add(g); nodes.push(g);
    });
    nodes.forEach(function(g){ map[g.getAttr('nid')] = g; });
    (data.connections || []).forEach(function(cm){
      var from = map[cm.from], to = map[cm.to]; if (!from || !to) return;
      var pts = calculatePoints(from, to);
      var arrow = new Konva.Arrow({ points: pts, pointerLength: 10, pointerWidth: 10, fill: '#ccc', stroke: '#ccc', strokeWidth: 1 });
      edgesLayer.add(arrow);
      connections.push({ from: from, to: to, arrow: arrow });
    });
    if (data.nidCounter) nidCounter = data.nidCounter;
    stage.batchDraw();
  } catch(e){ /* ignore */ }
}

// Initial mode + load saved
setMode('none');
loadState();
</script>
</body>
</html>
