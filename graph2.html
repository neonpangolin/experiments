<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mobile Graph Tool – Advanced Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <style>
    :root { --pt10px: 13.333px; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: var(--pt10px); }
    .toolbar { position: sticky; top: 0; display: flex; gap: 8px; align-items: center; padding: 8px; border-bottom: 1px solid #e6e6e6; background: #fff; z-index: 10; }
    .toolbar input[type="url"] { flex: 1; padding: 8px 10px; border: 1px solid #ddd; border-radius: 8px; min-width: 120px; }
    .toolbar button { padding: 8px 10px; border: 1px solid #ddd; border-radius: 8px; background: #fafafa; }
    .toolbar button.active { border-color: #333; background: #f0f0f0; }
    #stageWrap { height: calc(100dvh - 56px); width: 100vw; touch-action: none; background: #fff; }
    .hint { position: absolute; inset: auto 8px 8px 8px; padding: 6px 8px; border-radius: 8px; background: rgba(255,255,255,0.92); border: 1px solid #eee; pointer-events: none; }
  </style>
</head>
<body>
  <div class="toolbar">
    <input id="linkInput" type="url" placeholder="Paste a link (https://…)" inputmode="url" />
    <button id="addBtn" title="Add node">Add</button>
    <button id="connectBtn" title="Connect nodes">Connect</button>
    <button id="clearBtn" title="Clear canvas">Clear</button>
    <button id="saveBtn" title="Export PNG">Save PNG</button>
  </div>
  <div id="stageWrap"></div>
  <div class="hint" id="hint" style="display:none;"></div>

  <script>
    // === Constants ===
    const PT10 = 13.333; // 10pt
    const STORAGE_KEY = "graphTool_v2";
    const NODE_RADIUS = 28;
    const ICON_SIZE = 24; // SVG logo box

    // --- Simple Icons (subset) as inline SVG data URIs ---
    // Paths adapted from Simple Icons (https://simpleicons.org/) – simplified where possible.
    // (Logos are trademarks of their respective owners and used here for identification.)
    const SVG_ICONS = {
      facebook: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22.675 0H1.325C.593 0 0 .593 0 1.326v21.348C0 23.407.593 24 1.325 24h11.49v-9.294H9.691V11.06h3.124V8.413c0-3.1 1.894-4.788 4.66-4.788 1.325 0 2.463.099 2.795.143v3.24l-1.918.001c-1.504 0-1.796.715-1.796 1.765v2.315h3.587l-.467 3.647h-3.12V24h6.116C23.407 24 24 23.407 24 22.674V1.326C24 .593 23.407 0 22.675 0z"/></svg>',
      twitterx: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.244 2H21.5l-7.59 8.67L23.5 22h-7.08l-5.53-6.62L3.66 22H.5l8.1-9.26L.5 2h7.2l5.01 5.99L18.244 2Zm-1.24 18h1.94L7.06 4H5.06l11.944 16z"/></svg>',
      youtube: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M23.498 6.186a3.01 3.01 0 0 0-2.12-2.13C19.704 3.5 12 3.5 12 3.5s-7.704 0-9.378.556A3.01 3.01 0 0 0 .502 6.186C0 7.86 0 12 0 12s0 4.14.502 5.814a3.01 3.01 0 0 0 2.12 2.13C4.296 20.5 12 20.5 12 20.5s7.704 0 9.378-.556a3.01 3.01 0 0 0 2.12-2.13C24 16.14 24 12 24 12s0-4.14-.502-5.814zM9.75 15.5v-7L15.5 12l-5.75 3.5z"/></svg>',
      instagram: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7 2h10a5 5 0 0 1 5 5v10a5 5 0 0 1-5 5H7a5 5 0 0 1-5-5V7a5 5 0 0 1 5-5zm0 2a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3H7zm5 3.5a5.5 5.5 0 1 1 0 11 5.5 5.5 0 0 1 0-11zm0 2a3.5 3.5 0 1 0 0 7 3.5 3.5 0 0 0 0-7zM18 6.25a1.25 1.25 0 1 1 0 2.5 1.25 1.25 0 0 1 0-2.5z"/></svg>',
      linkedin: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4.98 3.5a2.5 2.5 0 1 1 0 5.001 2.5 2.5 0 0 1 0-5zM3 9h4v12H3zM14.5 9c-2.21 0-3.5 1.204-3.5 2.863V21h-4V9h4v1.65S12.09 9 14.7 9c2.61 0 4.3 1.73 4.3 4.73V21h-4v-6.5c0-1.4-.78-2.5-2.5-2.5z"/></svg>',
      reddit: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 12.5c0-.88-.72-1.6-1.6-1.6-.6 0-1.13.33-1.4.82-1.16-.73-2.68-1.2-4.35-1.27l.74-3.49 2.43.51a1.6 1.6 0 1 0 .2-1l-2.9-.6a.75.75 0 0 0-.88.56l-.96 4.49c-1.82.05-3.48.52-4.73 1.28-.28-.5-.81-.85-1.42-.85-.89 0-1.6.72-1.6 1.6 0 .66.39 1.22.95 1.47-.04.24-.06.48-.06.73 0 2.67 3.07 4.84 6.86 4.84s6.86-2.17 6.86-4.84c0-.25-.02-.5-.06-.74.56-.26.96-.82.96-1.46zM9.75 13.25a1.25 1.25 0 1 1 0 2.5 1.25 1.25 0 0 1 0-2.5zm6.5 0a1.25 1.25 0 1 1 0 2.5 1.25 1.25 0 0 1 0-2.5zM12 20c-2.2 0-4.12-.78-5.25-1.97.73.47 1.94.78 3.25.78 1.47 0 2.78-.37 3.57-.95.79.58 2.1.95 3.57.95 1.31 0 2.52-.31 3.25-.78C16.12 19.22 14.2 20 12 20z"/></svg>',
      tiktok: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13.5 3c.7 2.88 2.75 5.04 5.53 5.45v3.07c-1.9-.09-3.62-.77-5.03-1.83v6.9A5.56 5.56 0 1 1 8.44 9.5c.4 0 .78.05 1.15.14v3.2a2.78 2.78 0 1 0 1.91 2.64V3h1.99z"/></svg>',
      github: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 .5C5.73.5.98 5.24.98 11.5c0 4.85 3.15 8.96 7.5 10.41.55.1.75-.24.75-.53 0-.26-.01-1.13-.02-2.05-3.05.66-3.7-1.3-3.7-1.3-.5-1.28-1.22-1.62-1.22-1.62-.99-.67.07-.66.07-.66 1.1.08 1.69 1.12 1.69 1.12.98 1.67 2.56 1.19 3.18.91.1-.71.38-1.19.7-1.46-2.44-.28-5-1.22-5-5.45 0-1.2.43-2.18 1.13-2.96-.12-.28-.49-1.41.11-2.94 0 0 .92-.3 3.02 1.13a10.5 10.5 0 0 1 5.5 0c2.1-1.43 3.02-1.13 3.02-1.13.6 1.53.23 2.66.11 2.94.7.78 1.13 1.76 1.13 2.96 0 4.24-2.57 5.16-5.02 5.44.39.34.74 1 .74 2.01 0 1.45-.01 2.63-.01 2.99 0 .29.2.64.76.53 4.34-1.45 7.49-5.56 7.49-10.41C23.02 5.24 18.27.5 12 .5z"/></svg>',
      wikipedia: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M2 5h3.3l4.5 10.2L13.6 5H17l-5.5 12.7c-.2.46-.45.85-.78 1.17-.33.32-.8.63-1.37.63-.58 0-1.06-.3-1.4-.62-.33-.33-.58-.72-.78-1.18L2 5zm19.6 0H24l-4.92 11.36L17.5 13l4.1-8z"/></svg>',
      medium: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M2 7.5c0-.3.1-.6.3-.8L5 3.7V3H0v.7l2.2 2.8c.1.1.2.3.2.5v9c0 .2-.1.4-.2.5L0 19.3V20h7v-.7L4.8 17.3c-.1-.1-.2-.3-.2-.5v-9c0-.2.1-.4.2-.5L7 3.7V3H2v.7L.3 6.7c-.2.2-.3.5-.3.8v9c0 .3.1.6.3.8L2 19.3V20h5v-.7l-1.7-2.1c-.2-.2-.3-.5-.3-.8v-9zM24 20h-7v-.7l2.2-2.8c.1-.1.2-.3.2-.5v-9c0-.2-.1-.4-.2-.5L17 3.7V3h5v.7l1.7 2.1c.2.2.3.5.3.8v9c0 .3-.1.6-.3.8L22 19.3V20zM13.5 3h-3v14h3z"/></svg>',
      nytimes: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.9 9.1c.1.6.1 1.3.1 1.9 0 5-3.3 8.6-8.2 8.6-4.9 0-8.7-3.7-8.7-8.6 0-4.9 3.8-8.6 8.7-8.6 2.1 0 3.9.7 5.3 1.9l-1.7 1.7c-1-.8-2.2-1.3-3.6-1.3-3.3 0-5.6 2.4-5.6 6.3 0 3.8 2.3 6.3 5.6 6.3 2.8 0 4.6-1.7 5.1-4.1H10V9.1h9.9z"/></svg>',
      link: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3.9 12a4.1 4.1 0 0 1 4.1-4.1h3V9h-3a3 3 0 0 0 0 6h3v1.1h-3A4.1 4.1 0 0 1 3.9 12zm12.1-4.1h-3V9h3a3 3 0 0 1 0 6h-3v1.1h3a4.1 4.1 0 1 0 0-8.2zM8 11.4h8v1.2H8z"/></svg>'
    };

    const ICON_MAP = [
      {match: /facebook\.com/i, key: 'facebook', label: 'Facebook'},
      {match: /(twitter\.com|x\.com)/i, key: 'twitterx', label: 'Twitter/X'},
      {match: /youtube\.com|youtu\.be/i, key: 'youtube', label: 'YouTube'},
      {match: /instagram\.com/i, key: 'instagram', label: 'Instagram'},
      {match: /linkedin\.com/i, key: 'linkedin', label: 'LinkedIn'},
      {match: /reddit\.com/i, key: 'reddit', label: 'Reddit'},
      {match: /tiktok\.com/i, key: 'tiktok', label: 'TikTok'},
      {match: /github\.com/i, key: 'github', label: 'GitHub'},
      {match: /wikipedia\.org/i, key: 'wikipedia', label: 'Wikipedia'},
      {match: /medium\.com/i, key: 'medium', label: 'Medium'},
      {match: /nytimes\.com/i, key: 'nytimes', label: 'NYT'},
      {match: /.*/, key: 'link', label: 'Link'},
    ];

    function iconKeyFor(url){ const e = ICON_MAP.find(e=>e.match.test(url)); return e? e.key : 'link'; }
    function domainFrom(url){ try { return new URL(url).hostname.replace(/^www\./i, ""); } catch { return url; } }

    function svgToDataURL(svg){
      const encoded = encodeURIComponent(svg).replace(/'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29");
      return `data:image/svg+xml;charset=utf-8,${encoded}`;
    }

    // === Stage & Layers ===
    const stageWrap = document.getElementById('stageWrap');
    const stage = new Konva.Stage({ container: 'stageWrap', width: stageWrap.clientWidth, height: stageWrap.clientHeight });
    const backgroundLayer = new Konva.Layer();
    const edgesLayer = new Konva.Layer();
    const nodesLayer = new Konva.Layer();
    stage.add(backgroundLayer); stage.add(edgesLayer); stage.add(nodesLayer);

    // Grid (optional subtle dots)
    function drawGrid(){
      backgroundLayer.destroyChildren();
      const gap = 32;
      const { width, height } = stage.size();
      for(let x=0; x<width; x+=gap){
        for(let y=0; y<height; y+=gap){
          const dot = new Konva.Circle({ x, y, radius: 0.6, fill: '#eee', listening: false });
          backgroundLayer.add(dot);
        }
      }
      backgroundLayer.draw();
    }
    drawGrid();
    window.addEventListener('resize', ()=>{ stage.size({width: stageWrap.clientWidth, height: stageWrap.clientHeight}); drawGrid(); });

    // === State ===
    const graph = { nodes: [], edges: [] }; // nodes: {id,url,x,y,comment}
    let idSeq = 1;
    const byId = id => nodesLayer.findOne(`#node-${id}`);
    const edgeById = id => edgesLayer.findOne(`#edge-${id}`);

    // Selection state
    const selectedIds = new Set();
    let marqueeRect = null; let marqueeStart = null;

    // Connect mode state
    let connectMode = false; let connectStartId = null; let tempLine = null;

    // Pan/Zoom state
    let lastCenter = null; let lastDist = 0; let isPinching = false;

    function showHint(text, ms=1400){
      const el = document.getElementById('hint');
      el.textContent = text; el.style.display = 'block';
      clearTimeout(showHint._t); showHint._t = setTimeout(()=> el.style.display='none', ms);
    }

    // === Persistence ===
    function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify({ idSeq, nodes: graph.nodes, edges: graph.edges })); }
    function loadState(){
      const raw = localStorage.getItem(STORAGE_KEY); if(!raw) return;
      try{ const data = JSON.parse(raw); idSeq = data.idSeq || 1; graph.nodes = data.nodes||[]; graph.edges = data.edges||[]; graph.nodes.forEach(drawNode); graph.edges.forEach(drawEdge); }
      catch(e){ console.warn('Load failed', e); }
    }

    // === Helpers ===
    function relativePointer(){ return stage.getRelativePointerPosition() || stage.getPointerPosition(); }

    function drawTempLineFrom(group){ cancelTempLine(); const p = group.position(); tempLine = new Konva.Arrow({ points:[p.x,p.y,p.x,p.y], stroke:'#999', fill:'#999', pointerLength:8, pointerWidth:8, strokeWidth:1.5, dash:[6,4] }); edgesLayer.add(tempLine); stage.on('mousemove touchmove', ()=>{ const pos = relativePointer(); if(!pos) return; const gpos = group.position(); tempLine.points([gpos.x,gpos.y,pos.x,pos.y]); edgesLayer.batchDraw(); }); }
    function cancelTempLine(){ if(tempLine){ stage.off('mousemove touchmove'); tempLine.destroy(); tempLine=null; edgesLayer.draw(); } }

    function nodeCenterPoints(g1,g2){ return [g1.x(), g1.y(), g2.x(), g2.y()]; }

    function updateEdgesForNode(nodeId){ graph.edges.forEach(e=>{ if(e.from===nodeId||e.to===nodeId){ const ln = edgeById(e.id); if(ln){ const fromG = byId(e.from); const toG = byId(e.to); ln.points(nodeCenterPoints(fromG,toG)); } } }); edgesLayer.batchDraw(); }

    // === Node/Edge creation ===
    function addNodeFromUrl(url){ if(!/^https?:\/\//i.test(url)){ alert('Please enter a valid http(s) URL.'); return; } const node={ id:idSeq++, url:url.trim(), x: Math.round(stage.width()*(0.25+Math.random()*0.5)), y: Math.round(stage.height()*(0.25+Math.random()*0.5)), comment: ''}; graph.nodes.push(node); drawNode(node); saveState(); showHint('Node added.'); }

    function addEdge(fromId,toId){ const edge={ id:idSeq++, from:fromId, to:toId }; graph.edges.push(edge); drawEdge(edge); saveState(); }

    function removeNode(nodeId){ const g=byId(nodeId); g&&g.destroy(); const toRemove=graph.edges.filter(e=>e.from===nodeId||e.to===nodeId).map(e=>e.id); toRemove.forEach(removeEdge); const idx=graph.nodes.findIndex(n=>n.id===nodeId); if(idx>=0) graph.nodes.splice(idx,1); nodesLayer.draw(); edgesLayer.draw(); selectedIds.delete(nodeId); saveState(); }

    function removeEdge(edgeId){ const ln=edgeById(edgeId); ln&&ln.destroy(); const idx=graph.edges.findIndex(e=>e.id===edgeId); if(idx>=0) graph.edges.splice(idx,1); edgesLayer.draw(); saveState(); }

    function openLink(url){ window.open(url, '_blank', 'noopener,noreferrer'); }

    // === Selection visuals ===
    function setSelected(nodeId, on){ const g = byId(nodeId); if(!g) return; const circle = g.findOne('Circle'); if(on){ selectedIds.add(nodeId); circle.stroke('#0a84ff'); circle.strokeWidth(2); }
      else { selectedIds.delete(nodeId); circle.stroke('#444'); circle.strokeWidth(1.5); } nodesLayer.batchDraw(); }

    function clearSelection(){ [...selectedIds].forEach(id=> setSelected(id,false)); }

    // === Drawing nodes with SVG logo and texts ===
    function drawNode(node){
      const group = new Konva.Group({ id: `node-${node.id}`, x: node.x, y: node.y, draggable: true });

      const bg = new Konva.Circle({ radius: NODE_RADIUS, fill: '#f6f6f6', stroke: '#444', strokeWidth: 1.5, shadowColor: 'rgba(0,0,0,0.12)', shadowBlur: 6, shadowOffset: {x:0,y:1} });

      // SVG logo image
      const key = iconKeyFor(node.url);
      const svg = SVG_ICONS[key] || SVG_ICONS.link;
      const imgObj = new Image();
      imgObj.src = svgToDataURL(svg);
      const icon = new Konva.Image({ image: imgObj, width: ICON_SIZE, height: ICON_SIZE, offset: {x: ICON_SIZE/2, y: ICON_SIZE/2}, y: -2 });

      // domain label (10pt)
      const domainLabel = new Konva.Text({ text: domainFrom(node.url), fontFamily: 'Helvetica, Arial, sans-serif', fontSize: PT10, fill: '#333', y: NODE_RADIUS + 4, align: 'center' });
      // center later when added

      // comment text (10pt) under domain
      const commentText = new Konva.Text({ text: node.comment || '', fontFamily: 'Helvetica, Arial, sans-serif', fontSize: PT10, fill: '#111', y: NODE_RADIUS + 4 + PT10 + 4, width: 160, align: 'center' });
      commentText.offsetX(80); // center 160 width

      group.add(bg); group.add(icon); group.add(domainLabel); group.add(commentText);

      // center domain label based on width
      domainLabel.offsetX(domainLabel.width()/2);

      // --- Interactions ---
      // Click/tap for selection or connecting
      group.on('click touchstart', (evt)=>{
        if(connectMode){
          if(connectStartId==null){ connectStartId = node.id; showHint('Select a node to connect to…',2000); drawTempLineFrom(group); }
          else if(connectStartId===node.id){ cancelTempLine(); connectStartId=null; showHint('Canceled.',900); }
          else { addEdge(connectStartId, node.id); cancelTempLine(); connectStartId=null; setConnectMode(false); showHint('Nodes connected.',1200); }
          evt.cancelBubble = true; return;
        }
        // Toggle select with Shift/Ctrl (or single select otherwise)
        const multi = evt.evt && (evt.evt.shiftKey || evt.evt.ctrlKey || evt.evt.metaKey);
        if(!multi && !selectedIds.has(node.id)) clearSelection();
        setSelected(node.id, !selectedIds.has(node.id));
      });

      // Double-tap/double-click to add/edit comment (as requested)
      let tappedOnce=false; let tapTimer=null;
      group.on('mousedown touchstart', (e)=>{
        if(tappedOnce){
          clearTimeout(tapTimer); tappedOnce=false;
          const val = prompt('Add/edit comment for this node:', node.comment || '');
          if(val!==null){ node.comment = val.trim(); commentText.text(node.comment); nodesLayer.batchDraw(); saveState(); }
        } else {
          tappedOnce=true;
          tapTimer=setTimeout(()=>{ tappedOnce=false; }, 300);
        }
      });

      // Long-press to open link
      let pressTimer=null;
      group.on('touchstart', ()=>{ pressTimer = setTimeout(()=>{ openLink(node.url); }, 650); });
      group.on('touchend touchmove dragstart', ()=>{ if(pressTimer){ clearTimeout(pressTimer); pressTimer=null; } });

      // Dragging: move connected edges; if multi-selected, move group
      let dragOrigin = null; let groupStartPositions=null;
      group.on('dragstart', ()=>{
        // if this node is in selection and we have multiple, prepare group move
        const isMulti = selectedIds.has(node.id) && selectedIds.size>1;
        if(isMulti){
          dragOrigin = { x: group.x(), y: group.y() };
          groupStartPositions = [...selectedIds].map(id=>{ const g=byId(id); return { id, x:g.x(), y:g.y() }; });
        }
      });
      group.on('dragmove', ()=>{
        node.x = group.x(); node.y = group.y();
        if(groupStartPositions){
          // Move others by delta of this node from its start
          const dx = group.x() - dragOrigin.x; const dy = group.y() - dragOrigin.y;
          groupStartPositions.forEach(s=>{ if(s.id!==node.id){ const g=byId(s.id); g.position({ x: s.x + dx, y: s.y + dy }); const n=graph.nodes.find(nn=>nn.id===s.id); if(n){ n.x = g.x(); n.y = g.y(); } updateEdgesForNode(s.id); } });
        }
        updateEdgesForNode(node.id); saveState();
      });
      group.on('dragend', ()=>{ groupStartPositions=null; dragOrigin=null; saveState(); });

      nodesLayer.add(group); nodesLayer.draw();
      return group;
    }

    function drawEdge(edge){ const fromG = byId(edge.from); const toG = byId(edge.to); const line = new Konva.Arrow({ id:`edge-${edge.id}`, points: nodeCenterPoints(fromG,toG), stroke:'#666', fill:'#666', pointerLength:8, pointerWidth:8, strokeWidth:1.5, lineCap:'round', lineJoin:'round' }); line.on('click touchstart', ()=>{ if(confirm('Delete this connector?')) removeEdge(edge.id); }); edgesLayer.add(line); edgesLayer.draw(); return line; }

    // === Marquee selection ===
    function startMarquee(pos){ if(marqueeRect) marqueeRect.destroy(); marqueeStart = pos; marqueeRect = new Konva.Rect({ x: pos.x, y: pos.y, width: 0, height: 0, fill: 'rgba(10,132,255,0.08)', stroke: '#0a84ff', strokeWidth: 1, dash: [4,3] }); edgesLayer.add(marqueeRect); edgesLayer.draw(); }
    function updateMarquee(pos){ if(!marqueeRect||!marqueeStart) return; const x = Math.min(pos.x, marqueeStart.x); const y = Math.min(pos.y, marqueeStart.y); const w = Math.abs(pos.x - marqueeStart.x); const h = Math.abs(pos.y - marqueeStart.y); marqueeRect.position({x,y}); marqueeRect.size({width:w, height:h}); edgesLayer.batchDraw(); }
    function finishMarquee(){ if(!marqueeRect) return; const box = marqueeRect.getClientRect(); marqueeRect.destroy(); marqueeRect = null; marqueeStart = null; // select nodes intersecting
      const multiAdd = true; // marquee always sets a new selection
      clearSelection();
      nodesLayer.find('Group').forEach(g=>{ const r = g.getClientRect(); const intersect = !(r.x>box.x+box.width || r.x+r.width<box.x || r.y>box.y+box.height || r.y+r.height<box.y); if(intersect){ const id = parseInt(g.id().replace('node-','')); setSelected(id, true); } });
      showHint(`${selectedIds.size} selected`);
    }

    // === Pinch-to-zoom & pan ===
    function getDistance(p1, p2){ return Math.hypot(p1.x - p2.x, p1.y - p2.y); }
    function getCenter(p1, p2){ return { x: (p1.x+p2.x)/2, y: (p1.y+p2.y)/2 }; }

    stage.on('wheel', (e)=>{
      e.evt.preventDefault();
      const oldScale = stage.scaleX() || 1;
      const pointer = stage.getPointerPosition();
      const scaleBy = 1.04;
      const direction = e.evt.deltaY > 0 ? -1 : 1;
      let newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;
      newScale = Math.max(0.5, Math.min(3, newScale));
      const mousePointTo = { x: (pointer.x - stage.x()) / oldScale, y: (pointer.y - stage.y()) / oldScale };
      stage.scale({ x: newScale, y: newScale });
      const newPos = { x: pointer.x - mousePointTo.x * newScale, y: pointer.y - mousePointTo.y * newScale };
      stage.position(newPos);
      stage.batchDraw();
    });

    stage.on('touchmove', (e)=>{
      const touches = e.evt.touches;
      if(touches.length === 2){
        isPinching = true; e.evt.preventDefault();
        const p1 = { x: touches[0].clientX, y: touches[0].clientY };
        const p2 = { x: touches[1].clientX, y: touches[1].clientY };
        const center = getCenter(p1,p2);
        if(!lastCenter){ lastCenter = center; }
        const dist = getDistance(p1,p2);
        if(!lastDist){ lastDist = dist; }
        // compute scale
        const oldScale = stage.scaleX() || 1;
        let newScale = oldScale * (dist / lastDist);
        newScale = Math.max(0.5, Math.min(3, newScale));
        // scale around center
        const pointTo = { x: (center.x - stage.x()) / (stage.scaleX()||1), y: (center.y - stage.y()) / (stage.scaleY()||1) };
        stage.scale({ x: newScale, y: newScale });
        const newPos = { x: center.x - pointTo.x * newScale, y: center.y - pointTo.y * newScale };
        stage.position(newPos);
        stage.batchDraw();
        lastDist = dist; lastCenter = center;
      }
    });

    stage.on('touchend', (e)=>{
      if(e.evt.touches.length < 2){ lastCenter = null; lastDist = 0; if(isPinching){ isPinching=false; return; } }
    });

    // Two-finger pan is handled by same transform update above.

    // Marquee vs. panning: use single-finger drag on empty space for marquee
    stage.on('mousedown touchstart', (e)=>{
      if(isPinching) return; // ignore if pinch
      // only when clicking on empty area
      const isEmpty = e.target === stage || e.target.getParent() === backgroundLayer;
      if(isEmpty && (!connectMode)){
        const pos = relativePointer();
        startMarquee(pos);
      }
    });

    stage.on('mousemove touchmove', ()=>{ if(marqueeRect) updateMarquee(relativePointer()); });
    stage.on('mouseup touchend', ()=>{ if(marqueeRect) finishMarquee(); });

    function setConnectMode(on){ connectMode=on; document.getElementById('connectBtn').classList.toggle('active', on); if(on) showHint('Tap first node, then second node to connect.', 3000); cancelTempLine(); connectStartId=null; }

    // === UI wiring ===
    const inputEl = document.getElementById('linkInput');
    document.getElementById('addBtn').addEventListener('click', ()=>{ const url=inputEl.value.trim(); if(!url) return inputEl.focus(); addNodeFromUrl(url); inputEl.value=''; });
    inputEl.addEventListener('keydown', e=>{ if(e.key==='Enter') document.getElementById('addBtn').click(); });
    document.getElementById('connectBtn').addEventListener('click', ()=> setConnectMode(!connectMode));
    document.getElementById('clearBtn').addEventListener('click', ()=>{ if(!confirm('Clear the canvas and local data? This cannot be undone.')) return; graph.nodes.slice().forEach(n=> removeNode(n.id)); graph.edges.slice().forEach(e=> removeEdge(e.id)); localStorage.removeItem(STORAGE_KEY); idSeq=1; clearSelection(); showHint('Canvas cleared.'); });
    document.getElementById('saveBtn').addEventListener('click', ()=>{ const dataURL = stage.toDataURL({ pixelRatio: 2 }); const a=document.createElement('a'); a.href=dataURL; a.download='graph.png'; document.body.appendChild(a); a.click(); a.remove(); });

    // === Init ===
    loadState();
    showHint('Tip: Double-tap an icon to add a comment. Long-press opens the link.');
  </script>
</body>
</html>
