<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Graph Tool Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      font-family: Helvetica, sans-serif;
    }
    #container {
      width: 100vw;
      height: 100vh;
      touch-action: none; /* prevent scrolling on mobile */
    }
    /* Floating menu */
    .menu-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: #333;
      color: white;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      cursor: pointer;
      z-index: 1000;
    }
    .menu {
      position: fixed;
      bottom: 80px;
      right: 20px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      display: none;
      flex-direction: column;
      z-index: 1000;
    }
    .menu button {
      padding: 10px 20px;
      border: none;
      background: white;
      text-align: left;
      font-size: 14px;
      cursor: pointer;
    }
    .menu button:hover {
      background: #f0f0f0;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div class="menu-toggle">â‹®</div>
  <div class="menu">
    <button onclick="toggleConnect()">Connect</button>
    <button onclick="undo()">Undo</button>
    <button onclick="clearCanvas()">Clear</button>
    <button onclick="savePNG()">Save PNG</button>
  </div>

  <script>
    const stage = new Konva.Stage({
      container: 'container',
      width: window.innerWidth,
      height: window.innerHeight,
      draggable: true
    });
    const layer = new Konva.Layer();
    stage.add(layer);

    let isConnecting = false;
    let connectSource = null;
    let actionStack = [];

    const iconMap = {
      "facebook.com": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50"><circle cx="25" cy="25" r="25" fill="#1877F2"/><path d="M32 25h-4v12h-5V25h-3v-4h3v-3c0-2 1-5 5-5h4v4h-2c-1 0-2 1-2 2v2h4z" fill="#fff"/></svg>`,
      "twitter.com": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50"><circle cx="25" cy="25" r="25" fill="#1DA1F2"/><path d="M38 18c-1 1-2 1-3 2 1-1 1-2 1-3-1 1-2 1-3 2-1-1-2-2-4-2-3 0-6 3-6 6 0 .5 0 1 .1 1-5 0-9-3-11-6-.5 1-1 2-1 3s1 2 2 3c-1 0-2-.5-2-1 0 3 2 5 5 5-1 1-2 1-3 1h-1c1 2 3 3 6 3-2 1-4 2-7 2h-2c2 2 5 3 9 3 11 0 16-9 16-16v-1c1-1 2-2 2-3z" fill="#fff"/></svg>`,
      "youtube.com": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50"><rect width="50" height="50" rx="10" fill="#FF0000"/><polygon points="20,15 35,25 20,35" fill="#fff"/></svg>`,
      "default": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50"><circle cx="25" cy="25" r="25" fill="#555"/><path d="M15 25h20M25 15v20" stroke="#fff" stroke-width="3"/></svg>`
    };

    function detectIcon(url) {
      for (let key in iconMap) {
        if (url.includes(key)) return iconMap[key];
      }
      return iconMap["default"];
    }

    function addNodeFromClipboard(pos) {
      navigator.clipboard.readText().then(text => {
        if (!text) {
          showTooltip("Clipboard empty!", pos);
          return;
        }
        const iconSVG = detectIcon(text);
        const group = new Konva.Group({
          x: pos.x,
          y: pos.y,
          draggable: true
        });
        const svg = new Konva.Path({
          data: new window.DOMParser().parseFromString(iconSVG, "image/svg+xml").querySelector("svg").outerHTML,
        });
        Konva.Path.fromSVG(iconSVG, function(shapes) {
          shapes.forEach(shape => group.add(shape));
          group.on("dblclick dbltap", () => addComment(group));
          group.on("click tap", () => handleNodeClick(group, text));
          layer.add(group);
          layer.draw();
          actionStack.push({type: "add-node", node: group});
        });
      });
    }

    function addComment(group) {
      const comment = prompt("Enter comment:");
      if (!comment) return;
      const textNode = new Konva.Text({
        text: comment,
        fontSize: 10,
        fontFamily: "Helvetica",
        x: -25,
        y: 40,
        width: 50,
        align: "center"
      });
      group.add(textNode);
      layer.draw();
    }

    function handleNodeClick(node, url) {
      if (isConnecting) {
        if (!connectSource) {
          connectSource = node;
        } else {
          const line = new Konva.Line({
            points: [connectSource.x(), connectSource.y(), node.x(), node.y()],
            stroke: "black",
            strokeWidth: 2
          });
          layer.add(line);
          layer.moveToBottom(line);
          layer.draw();
          actionStack.push({type: "add-connection", line: line});
          connectSource = null;
        }
      } else {
        window.open(url, "_blank");
      }
    }

    function showTooltip(msg, pos) {
      const tooltip = new Konva.Text({
        text: msg,
        x: pos.x,
        y: pos.y,
        fontSize: 12,
        fontFamily: "Helvetica",
        fill: "red"
      });
      layer.add(tooltip);
      layer.draw();
      setTimeout(() => { tooltip.destroy(); layer.draw(); }, 1500);
    }

    function toggleConnect() {
      isConnecting = !isConnecting;
    }

    function undo() {
      const last = actionStack.pop();
      if (!last) return;
      if (last.type === "add-node") {
        last.node.destroy();
      } else if (last.type === "add-connection") {
        last.line.destroy();
      }
      layer.draw();
    }

    function clearCanvas() {
      layer.destroyChildren();
      actionStack = [];
      layer.draw();
    }

    function savePNG() {
      const dataURL = stage.toDataURL();
      const link = document.createElement('a');
      link.download = 'graph.png';
      link.href = dataURL;
      link.click();
    }

    // Pinch zoom
    let lastDist = 0;
    stage.on('wheel', e => {
      e.evt.preventDefault();
      const oldScale = stage.scaleX();
      const pointer = stage.getPointerPosition();
      const scaleBy = 1.05;
      const newScale = e.evt.deltaY > 0 ? oldScale / scaleBy : oldScale * scaleBy;
      stage.scale({ x: newScale, y: newScale });
      const mousePointTo = {
        x: (pointer.x - stage.x()) / oldScale,
        y: (pointer.y - stage.y()) / oldScale
      };
      stage.position({
        x: pointer.x - mousePointTo.x * newScale,
        y: pointer.y - mousePointTo.y * newScale
      });
      stage.batchDraw();
    });
    stage.on('touchmove', e => {
      const t = e.evt.touches;
      if (t.length === 2) {
        e.evt.preventDefault();
        const dist = Math.sqrt((t[0].clientX - t[1].clientX) ** 2 + (t[0].clientY - t[1].clientY) ** 2);
        if (!lastDist) lastDist = dist;
        let scale = stage.scaleX() * dist / lastDist;
        stage.scale({ x: scale, y: scale });
        stage.batchDraw();
        lastDist = dist;
      }
    });
    stage.on('touchend', () => { lastDist = 0; });

    // Add node on tap canvas
    stage.on("click tap", e => {
      if (e.target === stage) {
        addNodeFromClipboard(stage.getPointerPosition());
      }
    });

    // Resize stage & keep center
    window.addEventListener('resize', () => {
      stage.width(window.innerWidth);
      stage.height(window.innerHeight);
      stage.draw();
    });

    // Menu toggle
    const menuToggle = document.querySelector('.menu-toggle');
    const menu = document.querySelector('.menu');
    menuToggle.addEventListener('click', () => {
      menu.style.display = menu.style.display === 'flex' ? 'none' : 'flex';
    });
  </script>
</body>
</html>