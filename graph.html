<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lightweight Visual Graphing Tool</title>
    <style>
        body {
            font-family: Helvetica, sans-serif;
            font-size: 10pt;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #toolbar {
            padding: 5px;
            background: #eee;
            display: flex;
            gap: 5px;
        }
        #url-input {
            flex: 1;
        }
        #canvas {
            width: 100%;
            height: calc(100vh - 40px);
            position: relative;
        }
        #svg {
            width: 100%;
            height: 100%;
            background: #fff;
        }
        .node {
            cursor: move;
        }
        .selected {
            filter: drop-shadow(0 0 2px blue);
        }
        .edge {
            stroke: #ccc;
            stroke-width: 1;
            fill: none;
        }
        button.active {
            background: #ccc;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <input id="url-input" type="text" placeholder="Paste link here">
        <button id="add-btn">Add</button>
        <button id="connect-btn">Connect</button>
        <button id="undo-btn">Undo</button>
        <button id="clear-btn">Clear</button>
        <button id="export-btn">Export PNG</button>
    </div>
    <div id="canvas">
        <svg id="svg" xmlns="http://www.w3.org/2000/svg">
            <g id="zoom-group">
                <g id="edges-group"></g>
                <g id="nodes-group"></g>
            </g>
        </svg>
    </div>
    <script>
        const svgNS = 'http://www.w3.org/2000/svg';
        const xlinkNS = 'http://www.w3.org/1999/xlink';

        const icons = {
            twitter: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#000" d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24h-6.657l-5.214-6.817-5.97 6.817h-3.31l7.73-8.835-8.14-10.665h6.826l4.713 6.231 5.49-6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>',
            facebook: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#1877F2" d="M9 8h-3v4h3v12h5v-12h3.642l.358-4h-4v-1.667c0-.955.192-1.333 1.115-1.333h2.885v-5h-3.808c-3.596 0-4.192 2.133-4.192 4v4z"/></svg>',
            youtube: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#FF0000" d="M23.5 6.5c-.3-1.1-1.1-1.9-2.2-2.2-2-.3-10.3-.3-12.3 0-1.1.3-1.9 1.1-2.2 2.2-.3 2-.3 6.5 0 8.5.3 1.1 1.1 1.9 2.2 2.2 2 .3 10.3.3 12.3 0 1.1-.3 1.9-1.1 2.2-2.2.3-2 .3-6.5 0-8.5zm-13.5 7.5v-5l5 2.5-5 2.5z"/></svg>',
            instagram: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect width="20" height="20" x="2" y="2" rx="5" ry="5" fill="none" stroke="#E1306C" stroke-width="2"/><path fill="#E1306C" d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z"/><line stroke="#E1306C" stroke-width="2.5" x1="17.5" x2="17.51" y1="6.5" y2="6.5"/></svg>',
            default: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#000" d="M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3"/></svg>'
        };

        const domainToIcon = {
            'twitter.com': 'twitter',
            'x.com': 'twitter',
            'facebook.com': 'facebook',
            'youtube.com': 'youtube',
            'youtu.be': 'youtube',
            'instagram.com': 'instagram'
        };

        function getIcon(url) {
            try {
                const hostname = new URL(url).hostname;
                for (const domain in domainToIcon) {
                    if (hostname.includes(domain)) {
                        return domainToIcon[domain];
                    }
                }
            } catch (e) {}
            return 'default';
        }

        const svg = document.getElementById('svg');
        const zoomGroup = document.getElementById('zoom-group');
        const edgesGroup = document.getElementById('edges-group');
        const nodesGroup = document.getElementById('nodes-group');

        let nodes = [];
        let edges = [];
        let scale = 1;
        let panX = 0;
        let panY = 0;
        let mode = 'default'; // 'default', 'connect'
        let selectedNodes = new Set();
        let connectStart = null;

        let isDragging = false;
        let dragTarget = null;
        let startX = 0;
        let startY = 0;

        let pinchStartDist = 0;
        let pinchStartScale = 1;
        let pinchStartMidX = 0;
        let pinchStartMidY = 0;

        let history = [];
        let lastTapTime = 0;
        let lastTapId = null;
        let lastClickTime = 0;
        let lastClickId = null;

        const STORAGE_KEY = 'graph-data';
        const TAP_THRESHOLD = 5; // pixels
        const DOUBLE_TAP_TIME = 300; // ms

        function updateTransform() {
            zoomGroup.setAttribute('transform', `translate(${panX} ${panY}) scale(${scale})`);
        }

        function getCurrentState() {
            return {
                nodes: nodes.map(n => ({id: n.id, url: n.url, x: n.x, y: n.y, desc: n.desc})),
                edges: edges.map(e => ({from: e.from, to: e.to})),
                scale,
                panX,
                panY
            };
        }

        function pushHistory() {
            const state = getCurrentState();
            history.push(JSON.stringify(state));
            if (history.length > 20) {
                history.shift();
            }
        }

        function restoreState(state) {
            const data = JSON.parse(state);
            nodes.forEach(n => n.element.remove());
            edges.forEach(e => e.element.remove());
            nodes = [];
            edges = [];
            nodes = data.nodes.map(n => {
                const node = {...n, element: createNodeElement(n.id, n.url, n.x, n.y, n.desc)};
                nodesGroup.appendChild(node.element);
                return node;
            });
            edges = data.edges.map(e => {
                const edgeEl = createEdgeElement(e.from, e.to);
                edgesGroup.appendChild(edgeEl);
                return {...e, element: edgeEl};
            });
            scale = data.scale || 1;
            panX = data.panX || 0;
            panY = data.panY || 0;
            updateTransform();
            selectedNodes.clear();
            connectStart = null;
            document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            saveToLocal();
        }

        function undo() {
            if (history.length > 0) {
                restoreState(history.pop());
            }
        }

        function saveToLocal() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(getCurrentState()));
        }

        function loadFromLocal() {
            const dataStr = localStorage.getItem(STORAGE_KEY);
            if (dataStr) {
                restoreState(dataStr);
            }
        }

        function createNodeElement(id, url, x, y, desc = '') {
            const g = document.createElementNS(svgNS, 'g');
            g.setAttribute('class', 'node');
            g.setAttribute('transform', `translate(${x} ${y})`);
            g.dataset.id = id;

            const a = document.createElementNS(svgNS, 'a');
            a.setAttributeNS(xlinkNS, 'href', url);
            a.setAttribute('target', '_blank');

            const iconType = getIcon(url);
            const image = document.createElementNS(svgNS, 'image');
            image.setAttribute('width', '32');
            image.setAttribute('height', '32');
            image.setAttribute('x', '-16');
            image.setAttribute('y', '-16');
            image.setAttributeNS(xlinkNS, 'href', `data:image/svg+xml,${encodeURIComponent(icons[iconType])}`);

            a.appendChild(image);
            g.appendChild(a);

            if (desc) {
                const text = document.createElementNS(svgNS, 'text');
                text.setAttribute('x', '0');
                text.setAttribute('y', '20');
                text.setAttribute('text-anchor', 'middle');
                text.textContent = desc;
                g.appendChild(text);
            }

            return g;
        }

        function calculatePathD(from, to) {
            return `M${from.x} ${from.y} L${to.x} ${to.y}`;
        }

        function createEdgeElement(fromId, toId) {
            const fromNode = nodes.find(n => n.id === fromId);
            const toNode = nodes.find(n => n.id === toId);
            if (!fromNode || !toNode) return null;

            const path = document.createElementNS(svgNS, 'path');
            path.setAttribute('class', 'edge');
            path.setAttribute('d', calculatePathD(fromNode, toNode));
            path.dataset.from = fromId;
            path.dataset.to = toId;
            return path;
        }

        function updateEdgesForNode(nodeId) {
            edges.filter(e => e.from === nodeId || e.to === nodeId).forEach(e => {
                const from = nodes.find(n => n.id === e.from);
                const to = nodes.find(n => n.id === e.to);
                e.element.setAttribute('d', calculatePathD(from, to));
            });
        }

        function addNode(url) {
            if (!url) return;
            pushHistory();
            const id = Date.now();
            const viewWidth = svg.clientWidth / scale;
            const viewHeight = svg.clientHeight / scale;
            const x = (viewWidth / 2 - panX / scale) + Math.random() * 50 - 25;
            const y = (viewHeight / 2 - panY / scale) + Math.random() * 50 - 25;
            const element = createNodeElement(id, url, x, y);
            nodesGroup.appendChild(element);
            nodes.push({id, url, x, y, element, desc: ''});
            saveToLocal();
        }

        function addEdge(fromId, toId) {
            if (fromId === toId || edges.some(e => (e.from === fromId && e.to === toId) || (e.from === toId && e.to === fromId))) return;
            pushHistory();
            const element = createEdgeElement(fromId, toId);
            if (element) {
                edgesGroup.appendChild(element);
                edges.push({from: fromId, to: toId, element});
                saveToLocal();
            }
        }

        function clearCanvas() {
            pushHistory();
            nodes = [];
            edges = [];
            selectedNodes.clear();
            edgesGroup.innerHTML = '';
            nodesGroup.innerHTML = '';
            scale = 1;
            panX = 0;
            panY = 0;
            updateTransform();
            saveToLocal();
        }

        function exportPNG() {
            const svgData = new XMLSerializer().serializeToString(svg);
            const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
            const url = URL.createObjectURL(svgBlob);
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = svg.clientWidth;
                canvas.height = svg.clientHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const pngUrl = canvas.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = pngUrl;
                a.download = 'graph.png';
                a.click();
                URL.revokeObjectURL(url);
            };
            img.src = url;
        }

        function getEventPosition(e) {
            const rect = svg.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            return {
                x: (clientX - rect.left - panX) / scale,
                y: (clientY - rect.top - panY) / scale
            };
        }

        function getViewportPosition(e) {
            const rect = svg.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function handleStart(e) {
            if (e.touches && e.touches.length === 2) {
                e.preventDefault();
                const touch1 = getViewportPosition({clientX: e.touches[0].clientX, clientY: e.touches[0].clientY});
                const touch2 = getViewportPosition({clientX: e.touches[1].clientX, clientY: e.touches[1].clientY});
                pinchStartDist = Math.hypot(touch1.x - touch2.x, touch1.y - touch2.y);
                pinchStartMidX = (touch1.x + touch2.x) / 2;
                pinchStartMidY = (touch1.y + touch2.y) / 2;
                pinchStartScale = scale;
                return;
            }

            const target = e.target.closest('.node');
            startX = (e.clientX || e.touches[0].clientX);
            startY = (e.clientY || e.touches[0].clientY);
            isDragging = true;

            if (mode === 'connect') {
                if (target) {
                    const id = parseInt(target.dataset.id);
                    if (!connectStart) {
                        connectStart = id;
                        target.classList.add('selected');
                    } else {
                        addEdge(connectStart, id);
                        document.querySelector(`[data-id="${connectStart}"]`).classList.remove('selected');
                        connectStart = null;
                    }
                }
                return;
            }

            // Default mode
            if (target) {
                dragTarget = 'node';
                const id = parseInt(target.dataset.id);
                if (!selectedNodes.has(id)) {
                    selectedNodes.clear();
                    document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                    selectedNodes.add(id);
                    target.classList.add('selected');
                }
                // Store initial positions for all selected
                selectedNodes.forEach(selId => {
                    const node = nodes.find(n => n.id === selId);
                    node.startX = node.x;
                    node.startY = node.y;
                });
            } else {
                dragTarget = 'pan';
            }
        }

        function handleMove(e) {
            if (e.touches && e.touches.length === 2) {
                e.preventDefault();
                const touch1 = getViewportPosition({clientX: e.touches[0].clientX, clientY: e.touches[0].clientY});
                const touch2 = getViewportPosition({clientX: e.touches[1].clientX, clientY: e.touches[1].clientY});
                const newDist = Math.hypot(touch1.x - touch2.x, touch1.y - touch2.y);
                const newScale = pinchStartScale * (newDist / pinchStartDist);

                // Zoom at midpoint
                const midX = (touch1.x + touch2.x) / 2;
                const midY = (touch1.y + touch2.y) / 2;

                // World coord at start
                const worldX = (pinchStartMidX - panX) / scale;
                const worldY = (pinchStartMidY - panY) / scale;

                scale = newScale;
                panX = pinchStartMidX - worldX * newScale;
                panY = pinchStartMidY - worldY * newScale;

                updateTransform();
                return;
            }

            if (!isDragging) return;

            const currentX = (e.clientX || e.touches[0].clientX);
            const currentY = (e.clientY || e.touches[0].clientY);
            const dx = (currentX - startX) / scale;
            const dy = (currentY - startY) / scale;

            if (dragTarget === 'node') {
                selectedNodes.forEach(id => {
                    const node = nodes.find(n => n.id === id);
                    node.x = node.startX + dx;
                    node.y = node.startY + dy;
                    node.element.setAttribute('transform', `translate(${node.x} ${node.y})`);
                    updateEdgesForNode(id);
                });
            } else if (dragTarget === 'pan') {
                panX += (currentX - startX);
                panY += (currentY - startY);
                updateTransform();
                startX = currentX;
                startY = currentY;
            }
        }

        function handleEnd(e) {
            if (pinchStartDist > 0) {
                pinchStartDist = 0;
                saveToLocal();
                return;
            }

            const endX = (e.clientX || (e.changedTouches && e.changedTouches[0].clientX) || startX);
            const endY = (e.clientY || (e.changedTouches && e.changedTouches[0].clientY) || startY);
            const dist = Math.hypot(endX - startX, endY - startY);

            if (dragTarget === 'node' && dist < TAP_THRESHOLD && mode === 'default') {
                const target = e.target.closest('.node');
                if (target) {
                    const id = parseInt(target.dataset.id);
                    const node = nodes.find(n => n.id === id);
                    if (e.changedTouches) { // touch
                        const now = Date.now();
                        if (lastTapId === id && now - lastTapTime < DOUBLE_TAP_TIME) {
                            pushHistory();
                            const desc = prompt('Enter description:', node.desc || '');
                            if (desc !== null) {
                                node.desc = desc;
                                let textEl = target.querySelector('text');
                                if (!textEl) {
                                    textEl = document.createElementNS(svgNS, 'text');
                                    textEl.setAttribute('x', '0');
                                    textEl.setAttribute('y', '20');
                                    textEl.setAttribute('text-anchor', 'middle');
                                    target.appendChild(textEl);
                                }
                                textEl.textContent = desc;
                                saveToLocal();
                            }
                            lastTapTime = 0;
                            lastTapId = null;
                            if (connectStart) {
                                document.querySelector(`[data-id="${connectStart}"]`).classList.remove('selected');
                                connectStart = null;
                            }
                        } else {
                            if (connectStart) {
                                if (id !== connectStart) {
                                    addEdge(connectStart, id);
                                }
                                document.querySelector(`[data-id="${connectStart}"]`).classList.remove('selected');
                                connectStart = null;
                            } else {
                                connectStart = id;
                                target.classList.add('selected');
                            }
                            lastTapTime = now;
                            lastTapId = id;
                        }
                    } else { // mouse
                        const now = Date.now();
                        if (lastClickId === id && now - lastClickTime < DOUBLE_TAP_TIME) {
                            pushHistory();
                            const desc = prompt('Enter description:', node.desc || '');
                            if (desc !== null) {
                                node.desc = desc;
                                let textEl = target.querySelector('text');
                                if (!textEl) {
                                    textEl = document.createElementNS(svgNS, 'text');
                                    textEl.setAttribute('x', '0');
                                    textEl.setAttribute('y', '20');
                                    textEl.setAttribute('text-anchor', 'middle');
                                    target.appendChild(textEl);
                                }
                                textEl.textContent = desc;
                                saveToLocal();
                            }
                            lastClickTime = 0;
                            lastClickId = null;
                            if (connectStart) {
                                document.querySelector(`[data-id="${connectStart}"]`).classList.remove('selected');
                                connectStart = null;
                            }
                        } else {
                            if (connectStart) {
                                if (id !== connectStart) {
                                    addEdge(connectStart, id);
                                }
                                document.querySelector(`[data-id="${connectStart}"]`).classList.remove('selected');
                                connectStart = null;
                            } else {
                                connectStart = id;
                                target.classList.add('selected');
                            }
                            lastClickTime = now;
                            lastClickId = id;
                        }
                    }
                }
            } else if (dragTarget === 'pan' && dist < TAP_THRESHOLD && mode === 'default') {
                // Tap on background
                if (connectStart) {
                    document.querySelector(`[data-id="${connectStart}"]`).classList.remove('selected');
                    connectStart = null;
                }
            }

            if (dragTarget === 'node' || dragTarget === 'pan') {
                saveToLocal();
            }

            isDragging = false;
            dragTarget = null;
        }

        function handleClick(e) {
            if (mode !== 'default' || e.target.closest('.node')) return;
            // Click on bg in default: deselect all
            selectedNodes.clear();
            document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            if (connectStart) {
                document.querySelector(`[data-id="${connectStart}"]`).classList.remove('selected');
                connectStart = null;
            }
        }

        function setMode(newMode) {
            mode = newMode;
            document.querySelectorAll('#toolbar button').forEach(btn => btn.classList.remove('active'));
            if (newMode !== 'default') {
                document.getElementById(`${newMode}-btn`).classList.add('active');
            }
            if (newMode !== 'connect' && connectStart) {
                const startEl = document.querySelector(`[data-id="${connectStart}"]`);
                if (startEl) startEl.classList.remove('selected');
                connectStart = null;
            }
        }

        function handleKeyDown(e) {
            if (e.ctrlKey && e.key === 'z') {
                undo();
            }
        }

        // Event listeners
        svg.addEventListener('mousedown', handleStart);
        svg.addEventListener('mousemove', handleMove);
        svg.addEventListener('mouseup', handleEnd);
        svg.addEventListener('mouseleave', handleEnd);
        svg.addEventListener('touchstart', handleStart, {passive: false});
        svg.addEventListener('touchmove', handleMove, {passive: false});
        svg.addEventListener('touchend', handleEnd, {passive: false});
        svg.addEventListener('touchcancel', handleEnd, {passive: false});
        svg.addEventListener('click', handleClick);
        document.addEventListener('keydown', handleKeyDown);

        // Prevent link open in connect mode
        svg.addEventListener('click', e => {
            if (mode === 'connect' && e.target.closest('a')) {
                e.preventDefault();
                e.stopPropagation();
            }
        }, true);

        // Buttons
        document.getElementById('add-btn').addEventListener('click', () => {
            addNode(document.getElementById('url-input').value.trim());
            document.getElementById('url-input').value = '';
        });
        document.getElementById('url-input').addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                addNode(e.target.value.trim());
                e.target.value = '';
            }
        });
        document.getElementById('connect-btn').addEventListener('click', () => setMode(mode === 'connect' ? 'default' : 'connect'));
        document.getElementById('undo-btn').addEventListener('click', undo);
        document.getElementById('clear-btn').addEventListener('click', clearCanvas);
        document.getElementById('export-btn').addEventListener('click', exportPNG);

        // Load
        loadFromLocal();
    </script>
</body>
</html>
```
