<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Graph Tool – Final Polished Version</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <style>
    html, body {
      width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
      font-family: Helvetica, Arial, sans-serif; font-size: 1rem; color: #212121;
    }
    #stageWrap { position: fixed; inset: 0; touch-action: none; background: #f8f7f6; }

    /* Floating menu button and sheet */
    .fab {
      position: fixed; right: 16px; bottom: 16px;
      width: 56px; height: 56px; border-radius: 50%;
      background:#1d1c1b; color:#fff;
      display:flex; align-items:center; justify-content:center;
      font-size: 24px; box-shadow: 0 8px 20px rgba(0,0,0,.25);
      z-index: 9999; user-select: none; cursor: pointer;
    }
    .menu {
      position: fixed; right: 16px; bottom: 80px;
      background:#efeeed; color:#1d1c1b;
      border-radius: 12px; box-shadow: 0 10px 24px rgba(0,0,0,.18);
      display:none; flex-direction: column; overflow: hidden; z-index: 9999;
    }
    .menu button {
      border:0; background:#efeeed; color:#1d1c1b;
      padding: 12px 16px; text-align:left; font-size: 1rem; min-width: 180px; cursor: pointer;
    }
    .menu button:hover { background:#e1e0de; }

    .hint { position: fixed; left: 50%; transform: translateX(-50%); bottom: 10px; padding: 6px 10px; border-radius: 10px; background: rgba(29,28,27,0.9); color: #fff; z-index: 9998; opacity: 0; pointer-events: none; transition: opacity .15s; }
    .hint.show { opacity: 1; }
  
    /* Minimal URL prompt overlay as a secure-context fallback */
    .urlPromptOverlay {
      position: fixed; inset: 0; background: rgba(0,0,0,.28);
      display: none; align-items: center; justify-content: center; z-index: 10000;
    }
    .urlPromptCard {
      background: #fff; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,.25);
      padding: 16px; width: min(520px, 90vw);
      display: flex; gap: 8px; align-items: center;
    }
    .urlPromptCard input {
      flex: 1; padding: 10px 12px; font-size: 16px; border-radius: 8px; border: 1px solid #ddd;
    }
    .urlPromptCard button {
      padding: 10px 14px; border: 0; border-radius: 8px; background: #1d1c1b; color: #fff; cursor: pointer;
    }
    </style>
</head>
<body>
  <div id="stageWrap"></div>

  <div class="fab" id="fab" aria-label="Menu" title="Menu">⋮</div>
  <div class="menu" id="menu">
    <button id="btnAdd">Add from Clipboard</button>
    <button id="btnConnect">Connect</button>
    <button id="btnDelete">Delete</button>
    <button id="btnUndo">Undo</button>
    <button id="btnClear">Clear</button>
    <button id="btnSave">Save PNG</button>
  </div>

  <div class="hint" id="hint"></div>

  <script>
    /* ========= Config / Palette ========= */
    const COLORS = {
      canvasBg: '#f8f7f6',
      menuBg:   '#efeeed',
      menuText: '#1d1c1b',
      text:     '#212121',
      line:     '#e5e4e3',
      iconBg:   '#f3e8e2',
      icon:     '#934519'
    };
    const STORAGE_KEY = 'graphTool_final_v1';
    const NODE_RADIUS = 36;
    const ICON_SIZE = 28;

    // Brand SVGs (paths filled with palette icon color)
    const SVG_ICONS = {
      facebook: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#934519" d="M22.675 0H1.325C.593 0 0 .593 0 1.326v21.348C0 23.407.593 24 1.325 24h11.49v-9.294H9.691V11.06h3.124V8.413c0-3.1 1.894-4.788 4.66-4.788 1.325 0 2.463.099 2.795.143v3.24l-1.918.001c-1.504 0-1.796.715-1.796 1.765v2.315h3.587l-.467 3.647h-3.12V24h6.116C23.407 24 24 23.407 24 22.674V1.326C24 .593 23.407 0 22.675 0z"/></svg>',
      twitterx: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#934519" d="M18.244 2H21.5l-7.59 8.67L23.5 22h-7.08l-5.53-6.62L3.66 22H.5l8.1-9.26L.5 2h7.2l5.01 5.99L18.244 2Zm-1.24 18h1.94L7.06 4H5.06l11.944 16z"/></svg>',
      youtube:  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#934519" d="M23.498 6.186a3.01 3.01 0 0 0-2.12-2.13C19.704 3.5 12 3.5 12 3.5s-7.704 0-9.378.556A3.01 3.01 0 0 0 .502 6.186C0 7.86 0 12 0 12s0 4.14.502 5.814a3.01 3.01 0 0 0 2.12 2.13C4.296 20.5 12 20.5 12 20.5s7.704 0 9.378-.556a3.01 3.01 0 0 0 2.12-2.13C24 16.14 24 12 24 12s0-4.14-.502-5.814zM9.75 15.5v-7L15.5 12l-5.75 3.5z"/></svg>',
      instagram:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#934519" d="M12 2.163c3.204 0 3.584.012 4.85.07 1.17.056 1.97.24 2.427.403a4.92 4.92 0 0 1 1.75 1.145 4.92 4.92 0 0 1 1.145 1.75c.163.457.347 1.257.403 2.427.058 1.266.07 1.646.07 4.85s-.012 3.584-.07 4.85c-.056 1.17-.24 1.97-.403 2.427a4.92 4.92 0 0 1-1.145 1.75 4.92 4.92 0 0 1-1.75 1.145c-.457.163-1.257.347-2.427.403-1.266.058-1.646.07-4.85.07s-3.584-.012-4.85-.07c-1.17-.56-1.97-.24-2.427-.403a4.92 4.92 0 0 1-1.75-1.145 4.92 4.92 0 0 1-1.145-1.75c-.163-.457-.347-1.257-.403-2.427C2.175 15.747 2.163 15.367 2.163 12s.012-3.584.07-4.85c.056-1.17.24-1.97.403-2.427A4.92 4.92 0 0 1 3.781 2.973a4.92 4.92 0 0 1 1.75-1.145c.457-.163 1.257-.347 2.427-.403C8.416 1.65 8.796 1.638 12 1.638M12 5.838A6.162 6.162 0 0 0 5.838 12 6.162 6.162 0 0 0 12 18.162 6.162 6.162 0 0 0 18.162 12 6.162 6.162 0 0 0 12 5.838zm0 10.162A4 4 0 1 1 16 12a4 4 0 0 1-4 4zm6.406-11.845a1.44 1.44 0 1 1-2.88 0 1.44 1.44 0 0 1 2.88 0z"/></svg>',
      linkedin: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#934519" d="M20.447 20.452H16.9v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667h-3.549V9h3.414v1.561h.049c.476-.9 1.637-1.85 3.37-1.85 3.602 0 4.268 2.368 4.268 5.455v6.286zM5.337 7.433a2.062 2.062 0 1 1 0-4.125 2.062 2.062 0 0 1 0 4.125zM7.119 20.452H3.554V9h3.565v11.452zM22.225 0H1.771C.792 0 0 .771 0 1.729v20.542C0 23.229.792 24 1.771 24h20.451C23.2 24 24 23.229 24 22.271V1.729C24 .771 23.2 0 22.225 0z"/></svg>',
      reddit:   '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#934519" d="M24 12c0 6.627-5.373 12-12 12S0 18.627 0 12 5.373 0 12 0s12 5.373 12 12zM5.2 12.4a1.4 1.4 0 1 0 0-2.8 1.4 1.4 0 0 0 0 2.8zm13.6 0a1.4 1.4 0 1 0 0-2.8 1.4 1.4 0 0 0 0 2.8zM12 18.8c2.6 0 4.9-1.2 6.4-3.1a.7.7 0 1 0-1.1-.9 5.6 5.6 0 0 1-5.3 2.5 5.6 5.6 0 0 1-5.3-2.5.7.7 0 1 0-1.1.9c1.5 1.9 3.8 3.1 6.4 3.1z"/></svg>',
      github:   '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#934519" d="M12 .5C5.73.5.98 5.24.98 11.5c0 4.85 3.15 8.96 7.5 10.41.55.1.75-.24.75-.53 0-.26-.01-1.13-.02-2.05-3.05.66-3.7-1.3-3.7-1.3-.5-1.28-1.22-1.62-1.22-1.62-.99-.67.07-.66.07-.66 1.1.08 1.69 1.12 1.69 1.12.98 1.67 2.56 1.19 3.18.91.1-.71.38-1.19.7-1.46-2.44-.28-5-1.22-5-5.45 0-1.2.43-2.18 1.13-2.96-.12-.28-.49-1.41.11-2.94 0 0 .92-.3 3.02 1.13a10.5 10.5 0 0 1 5.5 0c2.1-1.43 3.02-1.13 3.02-1.13.6 1.53.23 2.66.11 2.94.7.78 1.13 1.76 1.13 2.96 0 4.24-2.57 5.16-5.02 5.44.39.34.74 1 .74 2.01 0 1.45-.01 2.63-.01 2.99 0 .29.2.64.76.53 4.34-1.45 7.49-5.56 7.49-10.41C23.02 5.24 18.27.5 12 .5z"/></svg>',
      wikipedia:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#934519" d="M2 5h3.3l4.5 10.2L13.6 5H17l-5.5 12.7c-.2.46-.45.85-.78 1.17-.33.32-.8.63-1.37.63-.58 0-1.06-.3-1.4-.62-.33-.33-.58-.72-.78-1.18L2 5zm19.6 0H24l-4.92 11.36L17.5 13l4.1-8z"/></svg>',
      medium:   '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#934519" d="M2 7.5c0-.3.1-.6.3-.8L5 3.7V3H0v.7l2.2 2.8c.1.1.2.3.2.5v9c0 .2-.1.4-.2.5L0 19.3V20h7v-.7l-1.7-2.1c-.2-.2-.3-.5-.3-.8v-9c0-.2.1-.4.2-.5L7 3.7V3H2v.7L.3 6.7c-.2.2-.3.5-.3.8v9c0 .3.1.6.3.8L2 19.3V20h5v-.7l-1.7-2.1c-.2-.2-.3-.5-.3-.8v-9zM24 20h-7v-.7l2.2-2.8c.1-.1.2-.3.2-.5v-9c0-.2-.1-.4-.2-.5L17 3.7V3h5v.7l1.7 2.1c.2.2.3.5.3.8v9c0 .3-.1 .6-.3 .8L22 19.3V20zM13.5 3h-3v14h3z"/></svg>',
      nytimes:  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#934519" d="M19.9 9.1c.1.6.1 1.3.1 1.9 0 5-3.3 8.6-8.2 8.6-4.9 0-8.7-3.7-8.7-8.6 0-4.9 3.8-8.6 8.7-8.6 2.1 0 3.9.7 5.3 1.9l-1.7 1.7c-1-.8-2.2-1.3-3.6-1.3-3.3 0-5.6 2.4-5.6 6.3 0 3.8 2.3 6.3 5.6 6.3 2.8 0 4.6-1.7 5.1-4.1H10V9.1h9.9z"/></svg>',
      link:     '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#934519" d="M3.9 12a4.1 4.1 0 0 1 4.1-4.1h3V9h-3a3 3 0 0 0 0 6h3v1.1h-3A4.1 4.1 0 0 1 3.9 12zm12.1-4.1h-3V9h3a3 3 0 0 1 0 6h-3v1.1h3a4.1 4.1 0 1 0 0-8.2zM8 11.4h8v1.2H8z"/></svg>'
    };

    const ICON_MAP = [
      {match:/facebook\.com/i,key:'facebook'},
      {match:/(twitter\.com|x\.com)/i,key:'twitterx'},
      {match:/youtube\.com|youtu\.be/i,key:'youtube'},
      {match:/instagram\.com/i,key:'instagram'},
      {match:/linkedin\.com/i,key:'linkedin'},
      {match:/reddit\.com/i,key:'reddit'},
      {match:/github\.com/i,key:'github'},
      {match:/wikipedia\.org/i,key:'wikipedia'},
      {match:/medium\.com/i,key:'medium'},
      {match:/nytimes\.com/i,key:'nytimes'},
      {match:/.*/,key:'link'}
    ];
    function iconKeyFor(url){ const e=ICON_MAP.find(e=>e.match.test(url)); return e? e.key:'link'; }
    function domainFrom(url){ try{return new URL(url).hostname.replace(/^www\./i,'');}catch{return url;} }
    function svgToDataURL(svg){ return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}`; }
    function normalizeUrl(u){
      try{
        const url = new URL(u.trim());
        url.hash = '';
        let href = url.href;
        if(href.endsWith('/')) href = href.slice(0,-1);
        return href;
      }catch{
        const s = (u||'').trim();
        return s.endsWith('/') ? s.slice(0,-1) : s;
      }
    }

    function ensureNodeIcon(id){
      const n = graph.nodes.find(nn=>nn.id===id); if(!n) return;
      const g = findNodeGroup(id); if(!g) return;
      if(g.findOne('.icon')) return;
      const key = iconKeyFor(n.url);
      const imgEl = new Image();
      imgEl.onload = ()=>{
        const kimg = new Konva.Image({ image: imgEl, width: 24, height: 24, offsetX: 12, y: -12, name: 'icon' });
        g.add(kimg); layer.draw();
      };
      try{ imgEl.src = svgToDataURL(ICONS[key]); }catch{ /* ignore */ }
    }


    
    function urlPrompt(){
      return new Promise((resolve)=>{
        const ov = document.getElementById('urlPromptOverlay');
        const input = document.getElementById('urlPromptInput');
        const ok = document.getElementById('urlPromptOk');
        function done(val){ cleanup(); resolve(val); }
        function cleanup(){
          ov.style.display='none'; ov.setAttribute('aria-hidden','true');
          input.value=''; ok.removeEventListener('click', onOk);
          input.removeEventListener('keydown', onKey);
          ov.removeEventListener('click', onOv);
          setTimeout(()=>input.blur(), 0);
        }
        function onKey(e){
          if(e.key==='Enter'){ const v=input.value.trim(); done(v? v:null); }
          else if(e.key==='Escape'){ done(null); }
        }
        function onOv(e){
          if(e.target===ov){ done(null); }
        }
        function onOk(){ const v=input.value.trim(); done(v? v:null); }
        ov.style.display='flex'; ov.setAttribute('aria-hidden','false');
        input.value=''; setTimeout(()=>{ input.focus(); input.select(); }, 0);
        ok.addEventListener('click', onOk);
        input.addEventListener('keydown', onKey);
        ov.addEventListener('click', onOv);
      });
    }
    /* ========= Stage / Groups ========= */
    const stageWrap = document.getElementById('stageWrap');
    const stage = new Konva.Stage({container:'stageWrap',width:stageWrap.clientWidth,height:stageWrap.clientHeight});
    const layer = new Konva.Layer(); stage.add(layer);
    const root = new Konva.Group({x:stage.width()/2,y:stage.height()/2,scaleX:1,scaleY:1});
    layer.add(root);
    const edgesLayer = new Konva.Group(), nodesLayer = new Konva.Group();
    root.add(edgesLayer); root.add(nodesLayer);
    // ---- Fallback drawNode if missing (ensures nodes render) ----
    if (typeof drawNode !== 'function') {
      function drawNode(node){
        const g=new Konva.Group({ id:`node-${node.id}`, x:node.x, y:node.y, draggable:true });

        const bg=new Konva.Circle({ radius: 24, fill: '#ffffff', stroke: '#e0dfde', strokeWidth: 1 });
        // label (domain)
        const label=new Konva.Text({ text: (domainFrom(node.url)||'link'), fontSize: 12, fill: '#333', y: 24+6, width: 200, align:'center' });
        label.offsetX(100);

        // icon (SVG -> Image)
        const key = iconKeyFor(node.url);
        const imgEl = new Image();
        imgEl.onload = ()=>{
          const kimg = new Konva.Image({ image: imgEl, width: 24, height: 24, offsetX: 12, y: -12, name: 'icon' });
          g.add(kimg); layer.draw();
        };
        try{ imgEl.src = svgToDataURL(ICONS[key]); }catch{}

        // click: set selection
        g.on('click tap', ()=>{ if(!connectMode && !deleteMode){ selectedId = node.id; } });

        // drag: update stored coords
        g.on('dragmove', ()=>{ node.x=g.x(); node.y=g.y(); });

        g.add(bg); g.add(label);
        nodesLayer.add(g); layer.draw();
      }
    }
    // simple helper to highlight selected node (optional ring)
    function highlightSelection(){
      nodesLayer.find('Group').forEach(gr=>{
        let ring = gr.findOne('.selring');
        const isSel = (selectedId && gr.id()===`node-${selectedId}`);
        if(isSel && !ring){
          ring = new Konva.Ring({ innerRadius: 26, outerRadius: 29, stroke: '#7aa0ff', strokeWidth: 2, name: 'selring' });
          gr.add(ring); gr.moveToTop();
        } else if(!isSel && ring){ ring.destroy(); }
      });
      layer.draw();
    }
    // Keep selection highlight fresh when clicking anywhere
    stage.on('click tap', highlightSelection);


    function resize(){ stage.size({width:stageWrap.clientWidth,height:stageWrap.clientHeight}); root.position({x:stage.width()/2,y:stage.height()/2}); stage.batchDraw(); }
    window.addEventListener('resize', resize);

    function toLocalFromStage(p){ const s=root.scaleX(); return { x:(p.x-root.x())/s, y:(p.y-root.y())/s }; }

    /* ========= Data & History ========= */
    const graph = { nodes: [], edges: [] }; // nodes: {id,url,x,y,comment}
    const urlSet = new Set();
    let idSeq=1, connectMode=false, connectStart=null, deleteMode=false, selectedId=null;
    const history=[]; // {type:'add-node'|'add-edge', id}
    const findNodeGroup = id => nodesLayer.findOne(`#node-${id}`);
    const findEdgeShape = id => edgesLayer.findOne(`#edge-${id}`);

    /* ========= Clipboard + Add ========= */
    async function readClipboardUrl(){
      // Try secure clipboard read first
      try{
        if(navigator.clipboard && window.isSecureContext){
          const text = await navigator.clipboard.readText();
          const m = text && text.match(/https?:\/\/[^\s\)\]}\\"'<>]+/i);
          if(m) return m[0];
          // No link in clipboard -> stay silent
          return null;
        }
      }catch(e){
        // If blocked or not allowed, fall through to prompt fallback below
      }
      // Fallback: if clipboard API is unavailable or blocked (e.g., file:// or http),
      // show a small inline prompt so the user can paste a link manually.
      try{
        const typed = await urlPrompt();
        const m = typed && typed.match(/https?:\/\/[^\s\)\]}\\"'<>]+/i);
        return m ? m[0] : null;
      }catch{ return null; }
    }
      try {
        if(m) return m[0];
      // If clipboard read fails or is not allowed, try to prompt the user
      } catch {}
      // No clipboard link -> be silent per requirement #2
      return null;
    

    function removeNode(id){
      const g=findNodeGroup(id); if(g) g.destroy();
      const n = graph.nodes.find(nn=>nn.id===id); if(n){ urlSet.delete(n.url); }
      graph.edges.filter(e=>e.from===id||e.to===id).map(e=>e.id).forEach(removeEdge);
      graph.nodes = graph.nodes.filter(n=>n.id!==id);
      layer.draw(); save();
    }
    function removeEdge(id){
      const ln=findEdgeShape(id); if(ln) ln.destroy();
      graph.edges = graph.edges.filter(e=>e.id!==id);
      layer.draw(); save();
    }

    /* ========= Persistence ========= */
    function save(){ localStorage.setItem(STORAGE_KEY, JSON.stringify({ idSeq, nodes: graph.nodes, edges: graph.edges })); }
    function load(){
      const raw = localStorage.getItem(STORAGE_KEY); if(!raw) return;
      try{ const d=JSON.parse(raw); idSeq=d.idSeq||1; graph.nodes=d.nodes||[]; graph.edges=d.edges||[];
        urlSet.clear(); graph.nodes.forEach(n=>{ const nu = normalizeUrl(n.url); n.url = nu; urlSet.add(nu); drawNode(n); ensureNodeIcon(n.id); });
        graph.edges.forEach(drawEdge);
      }catch(e){ console.warn('Failed to load', e); }
    }

    
    // Selection: remember last clicked node (no visual yet) for quick actions
    nodesLayer.on('click tap', (evt)=>{
      if(connectMode || deleteMode) return;
      let g = evt.target;
      while(g && g.getParent && g.getClassName && g.getClassName()!=='Group'){ g = g.getParent(); }
      if(g && g.id && typeof g.id==='function'){
        const gid = g.id();
        if(gid && gid.startsWith('node-')){
          const nid = parseInt(gid.slice(5), 10);
          if(!Number.isNaN(nid)) { selectedId = nid; highlightSelection(); }
        }
      }
    });
/* ========= Menu / Actions ========= */
    const fab=document.getElementById('fab'), menu=document.getElementById('menu');
    fab.addEventListener('click', ()=>{ menu.style.display = (menu.style.display==='flex') ? 'none' : 'flex'; if(menu.style.display==='flex') menu.style.flexDirection='column'; });

    function toast(msg, ms=1200){ const el=document.getElementById('hint'); el.textContent=msg; el.classList.add('show'); clearTimeout(toast._t); toast._t=setTimeout(()=>el.classList.remove('show'), ms); }
    function setConnect(on){ connectMode=on; if(on){ toast('Connect: tap first node'); } }

    document.getElementById('btnAdd').addEventListener('click', async ()=>{
      const url = await readClipboardUrl(); if(!url){ return; }
      addNode(url, {x:0, y:0}); // center of view (root coords)
    });
    document.getElementById('btnConnect').addEventListener('click', ()=>{ setConnect(!connectMode); if(!connectMode) connectStart=null; });
    document.getElementById('btnDelete').addEventListener('click', ()=>{ deleteMode = true; toast('Delete: tap a node'); });
    document.getElementById('btnUndo').addEventListener('click', ()=>{ const last=history.pop(); if(!last) return; if(last.type==='add-node'){ removeNode(last.id); } else if(last.type==='add-edge'){ removeEdge(last.id); } });
    document.getElementById('btnClear').addEventListener('click', ()=>{ if(!confirm('Clear the canvas and local data?')) return;
      nodesLayer.destroyChildren(); edgesLayer.destroyChildren(); graph.nodes=[]; graph.edges=[]; idSeq=1; history.length=0; layer.draw(); localStorage.removeItem(STORAGE_KEY);
    });
    document.getElementById('btnSave').addEventListener('click', ()=>{
      const dataURL = stage.toDataURL({ pixelRatio: 2, mimeType:'image/png', backgroundColor: COLORS.canvasBg });
      const a=document.createElement('a'); a.href=dataURL; a.download='graph.png'; document.body.appendChild(a); a.click(); a.remove();
    });

    /* ========= Interactions ========= */
    // Add by tapping empty canvas (clipboard -> prompt fallback)
    stage.on('click tap', async (evt)=>{
      if(evt.target !== stage) return;
      const url = await readClipboardUrl(); if(!url){ return; }
      const pos = toLocalFromStage(stage.getPointerPosition()); addNode(url, pos);
    });

    // Zoom: wheel + pinch (canvas only)
    stage.on('wheel', (e)=>{
      e.evt.preventDefault();
      const old = root.scaleX();
      const pointer = stage.getPointerPosition();
      const by = 1.05;
      let ns = e.evt.deltaY > 0 ? old/by : old*by;
      ns = Math.max(0.5, Math.min(3, ns));
      const mousePointTo = { x:(pointer.x-root.x())/old, y:(pointer.y-root.y())/old };
      root.scale({x:ns, y:ns});
      root.position({ x: pointer.x - mousePointTo.x*ns, y: pointer.y - mousePointTo.y*ns });
      stage.batchDraw();
    });

    let lastDist=0;
    stage.on('touchmove', (e)=>{
      const t=e.evt.touches; if(t.length!==2) return;
      e.evt.preventDefault();
      const dx=t[0].clientX - t[1].clientX, dy=t[0].clientY - t[1].clientY;
      const dist = Math.hypot(dx,dy);
      if(!lastDist){ lastDist=dist; return; }
      const old = root.scaleX();
      let ns = old * (dist/lastDist);
      ns = Math.max(0.5, Math.min(3, ns));
      const center = { x:(t[0].clientX+t[1].clientX)/2, y:(t[0].clientY+t[1].clientY)/2 };
      const pointTo = { x:(center.x-root.x())/old, y:(center.y-root.y())/old };
      root.scale({x:ns,y:ns});
      root.position({ x:center.x - pointTo.x*ns, y:center.y - pointTo.y*ns });
      stage.batchDraw();
      lastDist = dist;
    });
    stage.on('touchend', ()=>{ lastDist=0; });

    
    
    // ========= Keyboard Shortcuts =========

    async function addFromClipboardAtCenter(){
      const url = await readClipboardUrl(); if(!url) return;
      // drop at screen center in world coordinates
      const center = { x: stage.width()/2, y: stage.height()/2 };
      const pos = toLocalFromStage(center);
      addNode(url, pos);
    }
    // Use window listener with capture, and only suppress when a *visible* text field is focused
    window.addEventListener('keydown', async (e)=>{
      const el = e.target;
      const tag = (el && el.tagName) || '';
      const isFormEl = /INPUT|TEXTAREA|SELECT/.test(tag);
      const isEditable = el && el.isContentEditable;
      const isVisible = el && el.offsetParent !== null;
      if ((isFormEl || isEditable) && isVisible) return;
      const k = e.key;
      if(k === 'm' || k === 'M'){ e.preventDefault(); fab.click(); }
      else if(k === 'v' || k === 'V'){ e.preventDefault(); await addFromClipboardAtCenter(); }
      else if(k === 'c' || k === 'C'){ e.preventDefault(); setConnect(!connectMode); if(!connectMode) connectStart=null; }
      else if(k === 'z' || k === 'Z'){ e.preventDefault(); document.getElementById('btnUndo').click(); }
      else if(k === 'Delete'){ e.preventDefault(); if(selectedId!=null){ const id=selectedId; selectedId=null; removeNode(id); highlightSelection(); toast('Deleted'); } else { deleteMode = true; toast('Delete: tap a node'); } }
    }, true);
/* ========= Init ========= */
    function init(){ resize(); load(); toast('Tap canvas to add from clipboard • Double-tap a node to add a description • Use menu to connect/delete'); }
    init();
  </script>

  <div class="urlPromptOverlay" id="urlPromptOverlay" aria-hidden="true">
    <div class="urlPromptCard" role="dialog" aria-label="Paste a link">
      <input id="urlPromptInput" type="text" placeholder="Paste a link (https://...)" autocomplete="off" />
      <button id="urlPromptOk">Add</button>
    </div>
  </div>
</body>
</html>
